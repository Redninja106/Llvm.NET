<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Class ValueExtensions
   | Llvm.NET </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Class ValueExtensions
   | Llvm.NET ">
    <meta name="generator" content="docfx 2.29.1.0">
    
    <link rel="shortcut icon" href="../favicon.ico">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../DragonSharp48x48.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="Llvm.NET.Values.ValueExtensions">
  
  
  <h1 id="Llvm_NET_Values_ValueExtensions" data-uid="Llvm.NET.Values.ValueExtensions" class="text-break">Class ValueExtensions
  </h1>
  <div class="markdown level0 summary"><p>Provides extension methods to <a class="xref" href="Llvm.NET.Values.Value.html">Value</a> that cannot be achieved as members of the class</p>
</div>
  <div class="markdown level0 conceptual"></div>
  <div class="inheritance">
    <h5>Inheritance</h5>
    <div class="level0"><span class="xref">System.Object</span></div>
    <div class="level1"><span class="xref">ValueExtensions</span></div>
  </div>
  <div class="inheritedMembers">
    <h5>Inherited Members</h5>
    <div>
      <span class="xref">System.Object.ToString()</span>
    </div>
    <div>
      <span class="xref">System.Object.Equals(System.Object)</span>
    </div>
    <div>
      <span class="xref">System.Object.Equals(System.Object, System.Object)</span>
    </div>
    <div>
      <span class="xref">System.Object.ReferenceEquals(System.Object, System.Object)</span>
    </div>
    <div>
      <span class="xref">System.Object.GetHashCode()</span>
    </div>
    <div>
      <span class="xref">System.Object.GetType()</span>
    </div>
    <div>
      <span class="xref">System.Object.MemberwiseClone()</span>
    </div>
  </div>
  <h6><strong>Namespace</strong>: <a class="xref" href="Llvm.NET.Values.html">Llvm.NET.Values</a></h6>
  <h6><strong>Assembly</strong>: Llvm.NET.dll</h6>
  <h5 id="Llvm_NET_Values_ValueExtensions_syntax">Syntax</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static class ValueExtensions</code></pre>
  </div>
  <h5 id="Llvm_NET_Values_ValueExtensions_remarks"><strong>Remarks</strong></h5>
  <div class="markdown level0 remarks"><p>Using generic static extension methods allows for fluent coding while retaining the type of the &quot;this&quot; parameter.
If these were members of the <a class="xref" href="Llvm.NET.Values.Value.html">Value</a> class then the only return type could be <a class="xref" href="Llvm.NET.Values.Value.html">Value</a>,
thus losing the original type and requiring a cast to get back to it.</p>
</div>
  <h3 id="methods">Methods
  </h3>
  
  
  <a id="Llvm_NET_Values_ValueExtensions_RegisterName_" data-uid="Llvm.NET.Values.ValueExtensions.RegisterName*"></a>
  <h4 id="Llvm_NET_Values_ValueExtensions_RegisterName__1___0_System_String_" data-uid="Llvm.NET.Values.ValueExtensions.RegisterName``1(``0,System.String)">RegisterName&lt;T&gt;(T, String)</h4>
  <div class="markdown level1 summary"><p>Sets the virtual register name for a value</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static T RegisterName&lt;T&gt;(this T value, string name)where T : Value</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">T</span></td>
        <td><span class="parametername">value</span></td>
        <td><p>Value to set register name for</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">name</span></td>
        <td><p>Name for the virtual register the value represents</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">T</span></td>
        <td><p><code data-dev-comment-type="paramref" class="paramref">value</code> for fluent usage</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="typeParameters">Type Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="parametername">T</span></td>
        <td><p>Type of the value to set the name for</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Llvm_NET_Values_ValueExtensions_RegisterName__1___0_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Technically speaking only an <a class="xref" href="Llvm.NET.Instructions.Instruction.html">Instruction</a> can have register name
information. However, since LLVM will perform constant folding in the <a class="xref" href="Llvm.NET.Instructions.InstructionBuilder.html">InstructionBuilder</a>
most of the methods in <a class="xref" href="Llvm.NET.Instructions.InstructionBuilder.html">InstructionBuilder</a> return a <a class="xref" href="Llvm.NET.Values.Value.html">Value</a> rather
than a more specific <a class="xref" href="Llvm.NET.Instructions.Instruction.html">Instruction</a>. Thus, without this extension method here,
code would need to know ahead of time that an actual instruction would be produced then cast the result
to an <a class="xref" href="Llvm.NET.Instructions.Instruction.html">Instruction</a> and then set the debug location. This makes the code rather
ugly and tedious to manage. Placing this as a generic extension method ensures that the return type matches
the original and no additional casting is needed, which would defeat the purpose of doing this. For
<a class="xref" href="Llvm.NET.Values.Value.html">Value</a> types that are not instructions this does nothing. This allows for a simpler fluent
style of programming where the actual type is retained even in cases where an <a class="xref" href="Llvm.NET.Instructions.InstructionBuilder.html">InstructionBuilder</a>
method will always return an actual instruction.</p>
<p>Since the <a class="xref" href="Llvm.NET.Values.Value.html#Llvm_NET_Values_Value_Name">Name</a> property is available on all <a class="xref" href="Llvm.NET.Values.Value.html">Value</a>s this is slightly
redundant. It is useful for maintaining the fluent style of coding along with expressing intent more clearly.
(e.g. using this makes it expressly clear that the intent is to set the virtual register name and not the
name of a local variable etc...) Using the fluent style allows a significant reduction in the number of
overloaded methods in <a class="xref" href="Llvm.NET.Instructions.InstructionBuilder.html">InstructionBuilder</a> to account for all variations with or without a name.
</p>
</div>
  
  
  <a id="Llvm_NET_Values_ValueExtensions_SetDebugLocation_" data-uid="Llvm.NET.Values.ValueExtensions.SetDebugLocation*"></a>
  <h4 id="Llvm_NET_Values_ValueExtensions_SetDebugLocation__1___0_Llvm_NET_DebugInfo_DILocation_" data-uid="Llvm.NET.Values.ValueExtensions.SetDebugLocation``1(``0,Llvm.NET.DebugInfo.DILocation)">SetDebugLocation&lt;T&gt;(T, DILocation)</h4>
  <div class="markdown level1 summary"><p>Sets the debugging location for a value</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static T SetDebugLocation&lt;T&gt;(this T value, DILocation location)where T : Value</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">T</span></td>
        <td><span class="parametername">value</span></td>
        <td><p>Value to set debug location for</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="Llvm.NET.DebugInfo.DILocation.html">DILocation</a></td>
        <td><span class="parametername">location</span></td>
        <td><p>Debug location information</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">T</span></td>
        <td><p><code data-dev-comment-type="paramref" class="paramref">value</code> for fluent usage</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="typeParameters">Type Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="parametername">T</span></td>
        <td><p>Type of the value to tag</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Llvm_NET_Values_ValueExtensions_SetDebugLocation__1___0_Llvm_NET_DebugInfo_DILocation__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Technically speaking only an <a class="xref" href="Llvm.NET.Instructions.Instruction.html">Instruction</a> can have debug location
information. However, since LLVM will perform constant folding in the <a class="xref" href="Llvm.NET.Instructions.InstructionBuilder.html">InstructionBuilder</a>
most of the methods in <a class="xref" href="Llvm.NET.Instructions.InstructionBuilder.html">InstructionBuilder</a> return a <a class="xref" href="Llvm.NET.Values.Value.html">Value</a> rather than a
more specific <a class="xref" href="Llvm.NET.Instructions.Instruction.html">Instruction</a>. Thus, without this extension method, calling code
would need to know ahead of time that an actual instruction would be produced then cast the result to an
<a class="xref" href="Llvm.NET.Instructions.Instruction.html">Instruction</a> and then set the debug location. This makes the code rather ugly
and tedious to manage. Placing this as a generic extension method ensures that the return type matches
the original and no additional casting is needed, which would defeat the purpose of doing this. For
<a class="xref" href="Llvm.NET.Values.Value.html">Value</a> types that are not instructions this does nothing. This allows for a simpler fluent
style of programming where the actual type is retained even in cases where an <a class="xref" href="Llvm.NET.Instructions.InstructionBuilder.html">InstructionBuilder</a>
method will always return an actual instruction.</p>
<p>In order to help simplify code generation for cases where not all of the source information is
available this is a NOP if <code data-dev-comment-type="paramref" class="paramref">location</code> is null. Thus, it is safe to call even when
debugging information isn&apos;t actually available. This helps to avoid cluttering calling code with test
for debug info before trying to add it.</p>
</div>
  
  
  <a id="Llvm_NET_Values_ValueExtensions_SetDebugLocation_" data-uid="Llvm.NET.Values.ValueExtensions.SetDebugLocation*"></a>
  <h4 id="Llvm_NET_Values_ValueExtensions_SetDebugLocation__1___0_System_UInt32_System_UInt32_Llvm_NET_DebugInfo_DILocalScope_" data-uid="Llvm.NET.Values.ValueExtensions.SetDebugLocation``1(``0,System.UInt32,System.UInt32,Llvm.NET.DebugInfo.DILocalScope)">SetDebugLocation&lt;T&gt;(T, UInt32, UInt32, DILocalScope)</h4>
  <div class="markdown level1 summary"><p>Sets the debugging location for a value</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static T SetDebugLocation&lt;T&gt;(this T value, uint line, uint column, DILocalScope scope)where T : Value</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">T</span></td>
        <td><span class="parametername">value</span></td>
        <td><p>Value to set debug location for</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">line</span></td>
        <td><p>Line number</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">column</span></td>
        <td><p>Column number</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="Llvm.NET.DebugInfo.DILocalScope.html">DILocalScope</a></td>
        <td><span class="parametername">scope</span></td>
        <td><p>Scope for the value</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">T</span></td>
        <td><p><code data-dev-comment-type="paramref" class="paramref">value</code> for fluent usage</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="typeParameters">Type Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="parametername">T</span></td>
        <td><p>Type of the value to tag</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Llvm_NET_Values_ValueExtensions_SetDebugLocation__1___0_System_UInt32_System_UInt32_Llvm_NET_DebugInfo_DILocalScope__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Technically speaking only an <a class="xref" href="Llvm.NET.Instructions.Instruction.html">Instruction</a> can have debug location
information. However, since LLVM will perform constant folding in the <a class="xref" href="Llvm.NET.Instructions.InstructionBuilder.html">InstructionBuilder</a>
most of the methods in <a class="xref" href="Llvm.NET.Instructions.InstructionBuilder.html">InstructionBuilder</a> return a <a class="xref" href="Llvm.NET.Values.Value.html">Value</a> rather than a
more specific <a class="xref" href="Llvm.NET.Instructions.Instruction.html">Instruction</a>. Thus, without this extension method here,
code would need to know ahead of time that an actual instruction would be produced then cast the result
to an <a class="xref" href="Llvm.NET.Instructions.Instruction.html">Instruction</a> and then set the debug location. This makes the code rather
ugly and tedious to manage. Placing this as a generic extension method ensures that the return type matches
the original and no additional casting is needed, which would defeat the purpose of doing this. For
<a class="xref" href="Llvm.NET.Values.Value.html">Value</a> types that are not instructions this does nothing. This allows for a simpler fluent
style of programming where the actual type is retained even in cases where an <a class="xref" href="Llvm.NET.Instructions.InstructionBuilder.html">InstructionBuilder</a>
method will always return an actual instruction.</p>
<p>In order to help simplify code generation for cases where not all of the source information is
available this is a NOP if <code data-dev-comment-type="paramref" class="paramref">scope</code> is null. Thus, it is safe to call even when debugging
information isn&apos;t actually available. This helps to avoid cluttering calling code with test for debug info
before trying to add it.</p>
</div>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            Copyright (C) 2017, Dot NET Foundation
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
  </body>
</html>
