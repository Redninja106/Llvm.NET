<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>7. Kaleidoscope: Mutable Variables | Llvm.NET </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="7. Kaleidoscope: Mutable Variables | Llvm.NET ">
    <meta name="generator" content="docfx 2.33.2.0">
    
    <link rel="shortcut icon" href="../../favicon.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <meta property="docfx:navrel" content="../../toc">
    <meta property="docfx:tocrel" content="toc">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../DragonSharp48x48.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
                <ul class="nav level1 navbar-nav">
                  <li class="">
                    <a href="../../api/index.html" title="API Documentation" class="">API Documentation</a>
                  </li>
                  <li class="">
                    <a href="../../articles/index.html" title="Articles" class="">Articles</a>
                  </li>
                  <li class="">
                    <a href="https://github.com/UbiquityDotNET/Llvm.NET" title="GitHub Repository" class="">GitHub Repository</a>
                  </li>
                  <li class="">
                    <a href="http://LLVM.org" title="LLVM.org" class="">LLVM.org</a>
                  </li>
                  <li class="">
                    <a href="http://releases.llvm.org/5.0.1/docs/index.html" title="LLVM Docs" class="">LLVM Docs</a>
                  </li>
                </ul>
            </div>
          </div>
        </nav>
      </header>
      <div role="main" class="container body-content hide-when-search">
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div>
              <div class="sidefilter">
                <form class="toc-filter">
                  <span class="glyphicon glyphicon-filter filter-icon"></span>
                  <input type="text" id="toc_filter_input" placeholder="Enter here to filter..." onkeypress="if(event.keyCode==13) {return false;}">
                </form>
              </div>
              <div class="sidetoc">
                <div class="toc" id="toc">
                  
                  <ul class="nav level1">
                    <li class="">
                      <span class="expand-stub"></span>
                      <a class="">Code Generation</a>
                        
                        <ul class="nav level2">
                          <li class="">
                            <a href="codegeneration.html" title="CodeGenerator With Debug Information" class="">CodeGenerator With Debug Information</a>
                          </li>
                        </ul>  </li>
                    <li class="">
                      <span class="expand-stub"></span>
                      <a class="">Kaleidoscope</a>
                        
                        <ul class="nav level2">
                          <li class="">
                            <a href="Kaleidoscope.html" title="Chapter 1 - Language Introduction" class="">Chapter 1 - Language Introduction</a>
                          </li>
                          <li class="">
                            <a href="Kaleidoscope-ch2.html" title="Chapter 2 - Implementing the parser" class="">Chapter 2 - Implementing the parser</a>
                          </li>
                          <li class="">
                            <a href="Kaleidoscope-ch3.html" title="Chapter 3 - Generating LLVM IR" class="">Chapter 3 - Generating LLVM IR</a>
                          </li>
                          <li class="">
                            <a href="Kaleidoscope-ch4.html" title="Chapter 4 - JIT and Optimizer Support" class="">Chapter 4 - JIT and Optimizer Support</a>
                          </li>
                          <li class="">
                            <a href="Kaleidoscope-ch5.html" title="Chapter 5 - Control Flow" class="">Chapter 5 - Control Flow</a>
                          </li>
                          <li class="">
                            <a href="Kaleidoscope-ch6.html" title="Chapter 6 - User Defined Operators" class="">Chapter 6 - User Defined Operators</a>
                          </li>
                          <li class="active">
                            <a href="Kaleidoscope-ch7.html" title="Chapter 7 - Mutable Variables" class="active">Chapter 7 - Mutable Variables</a>
                          </li>
                          <li class="">
                            <a href="Kaleidoscope-ch8.html" title="Chapter 8 - AOT Compilation" class="">Chapter 8 - AOT Compilation</a>
                          </li>
                          <li class="">
                            <a href="Kaleidoscope-ch9.html" title="Chapter 9 - Debug Information" class="">Chapter 9 - Debug Information</a>
                          </li>
                          <li class="">
                            <a href="Kaleidoscope-ParseTreeVisitor.html" title="ParseTree Visitor" class="">ParseTree Visitor</a>
                          </li>
                          <li class="">
                            <a href="Kaleidoscope-Parsetree-examples.html" title="ParseTree Examples" class="">ParseTree Examples</a>
                          </li>
                        </ul>  </li>
                  </ul>        </div>
              </div>
            </div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="7-kaleidoscope-mutable-variables">7. Kaleidoscope: Mutable Variables</h1>

<p>The previous chapters introduced the Kaleidoscope language an progressively implemented a variety of
language features to make a fully featured, if not simplistic, functional programing language. To a
certain extent the choice of a functional language was a bit of a cheat. Generating LLVM IR for a 
functional language is really easy as functional languages map very easily into the LLVM native
<a href="http://en.wikipedia.org/wiki/Static_single_assignment_form">SSA form</a>. While the SSA form is very
useful for transformations and optimizations it is sometimes overwhelming to new users of LLVM. In
particular it may seem like LLVM doesn&#39;t support imperative languages with mutable variables or that
you need to convert all such languages into SSA form before generating LLVM IR. That is a bit of a
daunting task that might scare off a number of users. THe good news is, there is no need for a language
front-end to convert to SSA form directly. In fact it is generally discouraged! LLVM already has very
efficient, and more importantly, well tested, support for converting to SSA form (Though how that works
might be a bit surprising).</p>
<h2 id="mutable-variables-in-llvm">Mutable Variables in LLVM</h2>
<h3 id="mutable-varibales-vs-ssa-whats-the-big-deal">Mutable Varibales vs. SSA, What&#39;s the big deal?</h3>
<p>Consider the following simple &quot;C&quot; code:</p>
<pre><code class="lang-C">int G, H;

int test(_Bool Condition)
{
  int X;
  if (Condition)
    X = G;
  else
    X = H;
  return X;
}
</code></pre><p>The general idea of how to handle this in LLVM SSA form was already covered in <a href="Kaleidoscope-ch5.html">Chapter 5</a>.
Since there are two possible values for X when the function returns a PHI node inserted to merge the values. The
LLVM IR for this would look like this:</p>
<pre><code class="lang-llvm">@G = weak global i32 0   ; type of @G is i32*
@H = weak global i32 0   ; type of @H is i32*

define i32 @test(i1 %Condition) {
entry:
  br i1 %Condition, label %cond_true, label %cond_false

cond_true:
  %X.0 = load i32* @G
  br label %cond_next

cond_false:
  %X.1 = load i32* @H
  br label %cond_next

cond_next:
  %X.2 = phi i32 [ %X.1, %cond_false ], [ %X.0, %cond_true ]
  ret i32 %X.2
}
</code></pre><p>A full treatise on SSA is beyond the scope of this tutorial. If you are interested there are plenty of
<a href="http://en.wikipedia.org/wiki/Static_single_assignment_form">resources available on-line</a>. The focus for
this chapter is on how traditional imperative language front-ends can use the LLVM support for mutable
values without performing SSA conversion up-front. While, LLVM requires IR in SSA form (there&#39;s no such
thing as &quot;non-SSA mode&quot;). Constructing the SSA form requires non-trivial algorithms and data structures,
so it is both wasteful and error-prone for every front-end to have to manage implementing such a thing.</p>
<h3 id="memory-in-llvm">Memory in LLVM</h3>
<p>The trick to the apparent incompatibility of SSA in LLVM IR and mutable values in imperative languages
lies in how LLVM deals with memory. While LLVM requires all register values in SSA form, it does not require,
or even permit, memory objects in SSA form. In the preceding example access to global values G and H are
direct loads of memory. They are not named or versioned in any way. This differs from some other compiler
implementations that try to version memory objects. In LLVM, instead of encoding data-flow analysis of memory
in the IR, it is handled with Analysis Passes, which are computed on demand. This further helps to reduce the
work load of building a front-end.</p>
<p>Given all of that, the general idea is to create a stack variable, which lives in memory, for each mutable
object in a function. Since LLVM supports loads and stores from/to memory - mutable values are fairly straight
forward. Though, they may seem terribly inefficient at first. But, fear not LLVM has a way to deal with that.
Optimizations and efficiency is getting ahead of things a bit.</p>
<p>In LLVM, memory accesses are always explicit with load/store instructions. LLVM has no &quot;address-of&quot; operator,
and doesn&#39;t need one. Notice the type of the LLVM variables @G, and @H from the sample are actually <code>i32*</code>
even though the variable is defined as i32. In other words, @G (and @H) defines space for an i32, but the actual
symbolic name refers to the address for that space (e.g. it&#39;s a pointer). Stack variables work the same way,
except that instead of static allocation via a global declaration the are declared with the
<a class="xref" href="../../api/Llvm.NET.Instructions.Alloca.html">LLVM alloca instruction</a></p>
<pre><code class="lang-llvm">define i32 @example() {
entry:
  %X = alloca i32           ; type of %X is i32*.
  ...
  %tmp = load i32* %X       ; load the stack value %X from the stack.
  %tmp2 = add i32 %tmp, 1   ; increment it
  store i32 %tmp2, i32* %X  ; store it back
  ...
</code></pre><p>This code shows how LLVM supports creation and manipulation of stack based variables. Stack memory allocated
with alloca is completely generalized. you can pass the address of a stack slot to a function, store it in
a variable, etc... Using alloca, the previous example could be re-written using alloca without the PHI node
as follows:</p>
<pre><code class="lang-llvm">@G = weak global i32 0   ; type of @G is i32*
@H = weak global i32 0   ; type of @H is i32*

define i32 @test(i1 %Condition) {
entry:
  %X = alloca i32           ; type of %X is i32*.
  br i1 %Condition, label %cond_true, label %cond_false

cond_true:
  %X.0 = load i32* @G
  store i32 %X.0, i32* %X   ; Update X
  br label %cond_next

cond_false:
  %X.1 = load i32* @H
  store i32 %X.1, i32* %X   ; Update X
  br label %cond_next

cond_next:
  %X.2 = load i32* %X       ; Read X
  ret i32 %X.2
}
</code></pre><p>This example shows the general approach for handling arbitrary mutable values in LLVM IR without the need
for PHI nodes.</p>
<ol>
<li>Mutable Variables become a stack allocation</li>
<li>Reading the variable uses a load instruction to retrieve the value from memory</li>
<li>Updates of the variable becomes a store instruction to write the value to memory</li>
<li>Taking the address of a variable just uses the stack address directly</li>
</ol>
<p>This nicely and cleanly handles mutable variables in a fairly simple and easy to generate form. However, it
has apparently introduced a new problem. Every variable use requires stack memory and reads/writes operate
directly on stack memory - a major performance penalty. Fortunately, as previously hinted, LLVM has a well
tuned optimization pass named &quot;mem2reg&quot; that handles this case, promoting allocas into SSA registers, inserting
PHI nodes as necessary. For example if you run the alloca version of the IR code through the mem2reg optimization
pass you get:</p>
<pre><code class="lang-llvm">$ llvm-as &lt; example.ll | opt -mem2reg | llvm-dis
@G = weak global i32 0
@H = weak global i32 0

define i32 @test(i1 %Condition) {
entry:
  br i1 %Condition, label %cond_true, label %cond_false

cond_true:
  %X.0 = load i32* @G
  br label %cond_next

cond_false:
  %X.1 = load i32* @H
  br label %cond_next

cond_next:
  %X.01 = phi i32 [ %X.1, %cond_false ], [ %X.0, %cond_true ]
  ret i32 %X.01
}
</code></pre><p>The mem2reg pass implements the standard &quot;iterated dominance frontier&quot; algorithm for building
the SSA form with specialized optimizations to speed up common degenerate cases. The mem2reg pass
is an integral part o the full solution to mutable variables. Using mem2reg is highly recommended.
There are a few conditions for using mem2reg correctly.</p>
<ol>
<li>mem2reg is based on alloca: it looks for and promotes alloca. It does not apply to globals and heap allocations.</li>
<li>mem2reg only looks for alloca instructions in the entry block of the function. Placing allocas for all variables, 
in all scopes, in the entry block ensures they are executed only once, which makes the conversion simpler.</li>
<li>mem2reg only promotes allocas whose only uses are direct loads and stores. If the address of the object is passed 
to a function or any pointer math the alloca isn&#39;t promoted.</li>
<li>mem2reg only works on allocas of first class values (such as pointers scalars and vectors), and only if the array 
size of the allocation is 1. mem2reg is not capable of promoting structs or arrays to registers. (The SROA pass is more
powerful and can promote structs, unions and arrays in many cases)</li>
</ol>
<p>These may seem onerous but are really fairly straight forward and easy to abide, the rest of this chapter will focus on
doing that with the Kaleidoscope language. If you are considering doing your own SSA consider the following aspects of
the existing LLVM patterns and mem2reg:</p>
<ul>
<li>The mem2reg and alloca pattern is proven and very well tested. The most common clients of LLVM use this for the bulk of
their variables, bugs are found fast and early.</li>
<li>It is fast, the LLVM implementation has a number of optimizations that make it fast in common cases and fully general.
this includes fast-paths for variables used only in a single block, variables with only a single assignment point, and
heuristics to help avoid phi nodes when not needed.</li>
<li>It is needed for debug info generation, debug info in LLVM relies on having the address of the variable exposed so that
debugging data is attached to it. The mem2reg+alloca pattern fits well with this debug info style.</li>
<li>It&#39;s really simple to do, letting you focus on the core of the front-end instead of the details of correctly building
SSA form.</li>
</ul>
<h2 id="generating-llvm-ir-for-mutable-variables">Generating LLVM IR for Mutable Variables</h2>
<p>Now that we&#39;ve covered the general concepts of how LLVM supports mutable variables we can focus on implementing mutable
variables in Kaleidoscope. This includes the following new features:</p>
<ol>
<li>Mutate variables with an assignment operator &#39;=&#39;</li>
<li>Ability to define new variables</li>
</ol>
<p>Generally the first item is the primary feature here. Though, at this point, the Kaleidoscope language only has variables
for incoming arguments and for loop induction variables. Defining variables is just a generally useful concept that can
serve many purposes, including self documentation. The following is an example on how these features are used:</p>
<pre><code class="lang-Kaleidoscope"># Define &#39;:&#39; for sequencing: as a low-precedence operator that ignores operands
# and just returns the RHS.
def binary : 1 (x y) y;

# Recursive fib, we could do this before.
def fib(x)
  if (x &lt; 3) then
    1
  else
    fib(x-1)+fib(x-2);

# Iterative fib.
def fibi(x)
  var a = 1, b = 1, c in
  (for i = 3, i &lt; x in
     c = a + b :
     a = b :
     b = c) :
  b;

# Call it.
fibi(10);
</code></pre><p>In order to mutate variables the current implementation needs to change to leverage the &quot;alloca trick&quot;.
Then support for assignment will complete the mutable variables support.</p>
<h2 id="adjusting-existing-variables-for-mutation">Adjusting Existing Variables for Mutation</h2>
<p>Currently the symbol stack in Kaleidoscope stores LLVM Values directly. To support mutable values this
stack needs to switch to using <a class="xref" href="../../api/Llvm.NET.Instructions.Alloca.html">Alloca</a>.</p>
<pre><code class="lang-C#">private readonly ScopeStack&lt;Alloca&gt; NamedValues;
</code></pre><h3 id="add-createentryblockalloca">Add CreateEntryBlockAlloca</h3>
<p>To create the alloca instructions
in the entry block we&#39;ll add a new helper routine to build the instructions in the entry block.</p>
<pre><code class="lang-csharp" name="CreateEntryBlockAlloca">private static Alloca CreateEntryBlockAlloca( Function theFunction, string varName )
{
    var tmpBldr = new InstructionBuilder( theFunction.EntryBlock );
    if( theFunction.EntryBlock.FirstInstruction != null )
    {
        tmpBldr.PositionBefore( theFunction.EntryBlock.FirstInstruction );
    }

    return tmpBldr.Alloca( theFunction.Context.DoubleType )
                  .RegisterName( varName );
}
</code></pre><h3 id="update-visitvariableexpression">Update VisitVariableExpression</h3>
<p>The first change to the code generation is to update handling of variable expressions to generate
a load through the pointer created with an alloca instruction. This is pretty straight forward since the
scope map now stores the alloca instructions.</p>
<pre><code class="lang-csharp" name="VisitVariableExpression">public override Value VisitVariableExpression( [NotNull] VariableExpressionContext context )
{
    string varName = context.Name;
    if( !NamedValues.TryGetValue( varName, out Alloca value ) )
    {
        throw new CodeGeneratorException( $&quot;Unknown variable name: {context}&quot; );
    }

    return InstructionBuilder.Load( value )
                             .RegisterName( varName );
}
</code></pre><h3 id="update-visitconditionalexpression">Update VisitConditionalExpression</h3>
<p>Now that we have the alloca support we can update the conditional expression handling to remove the need for direct
PHI node construction. This involves adding a new compiler generated local var for the result of the condition and
storing the result value into that location for each side of the branch. Then, in the continue block load the value
from the location so that it is available as a value for the result of the expression.</p>
<pre><code class="lang-csharp" name="VisitConditionalExpression">public override Value VisitConditionalExpression( [NotNull] ConditionalExpressionContext context )
{
    var result = CreateEntryBlockAlloca( InstructionBuilder.InsertBlock.ContainingFunction, &quot;ifresult.alloca&quot; );

    var condition = context.Condition.Accept( this );
    if( condition == null )
    {
        return null;
    }

    var condBool = InstructionBuilder.Compare( RealPredicate.OrderedAndNotEqual, condition, Context.CreateConstant( 0.0 ) )
                                     .RegisterName( &quot;ifcond&quot; );

    var function = InstructionBuilder.InsertBlock.ContainingFunction;

    var thenBlock = Context.CreateBasicBlock( &quot;then&quot;, function );
    var elseBlock = Context.CreateBasicBlock( &quot;else&quot; );
    var continueBlock = Context.CreateBasicBlock( &quot;ifcont&quot; );
    InstructionBuilder.Branch( condBool, thenBlock, elseBlock );

    // generate then block
    InstructionBuilder.PositionAtEnd( thenBlock );
    var thenValue = context.ThenExpression.Accept( this );
    if( thenValue == null )
    {
        return null;
    }

    InstructionBuilder.Store( thenValue, result );
    InstructionBuilder.Branch( continueBlock );

    // capture the insert in case generating else adds new blocks
    thenBlock = InstructionBuilder.InsertBlock;

    // generate else block
    function.BasicBlocks.Add( elseBlock );
    InstructionBuilder.PositionAtEnd( elseBlock );
    var elseValue = context.ElseExpression.Accept( this );
    if( elseValue == null )
    {
        return null;
    }

    InstructionBuilder.Store( elseValue, result );
    InstructionBuilder.Branch( continueBlock );
    elseBlock = InstructionBuilder.InsertBlock;

    // generate continue block
    function.BasicBlocks.Add( continueBlock );
    InstructionBuilder.PositionAtEnd( continueBlock );
    return InstructionBuilder.Load( result )
                             .RegisterName( &quot;ifresult&quot; );
}
</code></pre><h3 id="update-visitforexpression">Update VisitForExpression</h3>
<p>Next up is to update the for loop handling to use the allocas. The code is almost identical except for the use
of load/store for the variables and removal of the manually generated PHI nodes.</p>
<pre><code class="lang-csharp" name="VisitForExpression">public override Value VisitForExpression( [NotNull] ForExpressionContext context )
{
    var function = InstructionBuilder.InsertBlock.ContainingFunction;
    string varName = context.Initializer.Name;
    var allocaVar = CreateEntryBlockAlloca( function, varName );

    // Emit the start code first, without &#39;variable&#39; in scope.
    Value startVal = null;
    if( context.Initializer.Value != null )
    {
        startVal = context.Initializer.Value.Accept( this );
        if( startVal == null )
        {
            return null;
        }
    }
    else
    {
        startVal = Context.CreateConstant( 0.0 );
    }

    // store the value into allocated location
    InstructionBuilder.Store( startVal, allocaVar );

    // Make the new basic block for the loop header, inserting after current
    // block.
    var preHeaderBlock = InstructionBuilder.InsertBlock;
    var loopBlock = Context.CreateBasicBlock( &quot;loop&quot;, function );

    // Insert an explicit fall through from the current block to the loopBlock.
    InstructionBuilder.Branch( loopBlock );

    // Start insertion in loopBlock.
    InstructionBuilder.PositionAtEnd( loopBlock );

    // Within the loop, the variable is defined equal to the PHI node.
    // So, push a new scope for it and any values the body might set
    using( NamedValues.EnterScope( ) )
    {
        NamedValues[ varName ] = allocaVar;

        // Emit the body of the loop.  This, like any other expr, can change the
        // current BB.  Note that we ignore the value computed by the body, but don&#39;t
        // allow an error.
        if( context.BodyExpression.Accept( this ) == null )
        {
            return null;
        }

        Value stepValue = Context.CreateConstant( 1.0 );

        if( context.StepExpression != null )
        {
            stepValue = context.StepExpression.Accept( this );
            if( stepValue == null )
            {
                return null;
            }
        }

        // Compute the end condition.
        Value endCondition = context.EndExpression.Accept( this );
        if( endCondition == null )
        {
            return null;
        }

        var curVar = InstructionBuilder.Load( allocaVar )
                                       .RegisterName( varName );
        var nextVar = InstructionBuilder.FAdd( curVar, stepValue )
                                        .RegisterName( &quot;nextvar&quot; );
        InstructionBuilder.Store( nextVar, allocaVar );

        // Convert condition to a bool by comparing non-equal to 0.0.
        endCondition = InstructionBuilder.Compare( RealPredicate.OrderedAndNotEqual, endCondition, Context.CreateConstant( 0.0 ) )
                                         .RegisterName( &quot;loopcond&quot; );

        // Create the &quot;after loop&quot; block and insert it.
        var loopEndBlock = InstructionBuilder.InsertBlock;
        var afterBlock = Context.CreateBasicBlock( &quot;afterloop&quot;, function );

        // Insert the conditional branch into the end of LoopEndBB.
        InstructionBuilder.Branch( endCondition, loopBlock, afterBlock );
        InstructionBuilder.PositionAtEnd( afterBlock );

        // for expression always returns 0.0 for consistency, there is no &#39;void&#39;
        return Context.DoubleType.GetNullValue( );
    }
}
</code></pre><h3 id="update-definefunction">Update DefineFunction</h3>
<p>To support mutable function argument variables the handler for functions requires a small update to create
the allocas for each incoming argument as well.</p>
<pre><code class="lang-csharp" name="DefineFunction">private (Function Function, IJitModuleHandle JitHandle) DefineFunction( Function function, ExpressionContext body )
{
    if( !function.IsDeclaration )
    {
        throw new CodeGeneratorException( $&quot;Function {function.Name} cannot be redefined in the same module&quot; );
    }

    // Destroy any previously generated module for this function.
    // This allows re-definition as the new module will provide the
    // implementation. This is needed, otherwise both the MCJIT
    // and OrcJit engines will resolve to the original module, despite
    // claims to the contrary in the official tutorial text. (Though,
    // to be fair it may have been true in the original JIT and might
    // still be true for the interpreter)
    if( FunctionModuleMap.Remove( function.Name, out IJitModuleHandle handle ) )
    {
        JIT.RemoveModule( handle );
    }

    var basicBlock = function.AppendBasicBlock( &quot;entry&quot; );
    InstructionBuilder.PositionAtEnd( basicBlock );
    using( NamedValues.EnterScope( ) )
    {
        foreach( var arg in function.Parameters )
        {
            var argSlot = CreateEntryBlockAlloca( function, arg.Name );
            InstructionBuilder.Store( arg, argSlot );
            NamedValues[ arg.Name ] = argSlot;
        }

        var funcReturn = body.Accept( this );
        if( funcReturn == null )
        {
            function.EraseFromParent( );
            return (null, default);
        }

        InstructionBuilder.Return( funcReturn );
        function.Verify( );
    }

    if( !DisableOptimizations )
    {
        FunctionPassManager.Run( function );
    }

    var jitHandle = JIT.AddModule( Module );
    FunctionModuleMap.Add( function.Name, jitHandle );
    InitializeModuleAndPassManager( );
    return (function, jitHandle);
}
</code></pre><p>The only change there is in the for loop used to create the argument variables via the previously created helper
function.</p>
<h3 id="initializemoduleandpassmanager">InitializeModuleAndPassManager</h3>
<p>The last piece required for mutable variables support is to include the optimization pass to promote memory to
registers.</p>
<pre><code class="lang-csharp" name="InitializeModuleAndPassManager">private void InitializeModuleAndPassManager( )
{
    Module = Context.CreateBitcodeModule( );
    Module.Layout = JIT.TargetMachine.TargetData;
    FunctionPassManager = new FunctionPassManager( Module )
                              .AddPromoteMemoryToRegisterPass( );

    if( !DisableOptimizations )
    {
        FunctionPassManager.AddInstructionCombiningPass( )
                           .AddReassociatePass( )
                           .AddGVNPass( )
                           .AddCFGSimplificationPass( );
    }

    FunctionPassManager.Initialize( );
}
</code></pre><h2 id="new-assignment-operator">New Assignment Operator</h2>
<p>Building on the existing code generation framework makes adding the new assignment operator. The parser already
knows how to parse the operator so we need to add code generation for the operator. This is split in two places
to handle the special nature of the assignment operator. The first step is to add handling the assign as a binary
operator to store the right hand value to the left hand value, which is an address from the alloca for the variable.</p>
<pre><code class="lang-C#">case ASSIGN:
    InstructionBuilder.Store( rhs, lhs );
    return rhs;
</code></pre><h3 id="update-visitexpression">Update VisitExpression</h3>
<p>Unlike the other binary operators assignment doesn&#39;t follow the same emit left, emit right, emit operator sequence.
This is because an expression like &#39;(x+1) = expression&#39; is nonsensical and therefore not allowed. The left hand side
is always an alloca as the destination of a store. To handle this special case the expression visitor is updated to
to perform a lookup of the left hand side variable for assignment instead of emitting the expression.</p>
<pre><code class="lang-csharp" name="VisitExpression">public override Value VisitExpression( [NotNull] ExpressionContext context )
{
    // Expression: PrimaryExpression (op expression)*
    // the sub-expressions are in evaluation order
    //
    // Special case the assignment operator as there isn&#39;t anything to emit
    // for the lhs expression. (If it was emitted it would be a load of the
    // value and assignment needs a place to store the value)
    Value lhs = null;
    var firstOp = context.GetChild&lt;ITerminalNode&gt;( 0 );
    if( context.IsAssignment )
    {
        var target = context.AssignmentTarget;
        if( !NamedValues.TryGetValue( target.Name, out Alloca varSlot ) )
        {
            throw new CodeGeneratorException( $&quot;Unknown variable name {target.Name}&quot; );
        }

        lhs = varSlot;
    }
    else
    {
        lhs = context.primaryExpression( ).Accept( this );
    }

    foreach( var (op, rhs) in context.OperatorExpressions )
    {
        lhs = EmitBinaryOperator( lhs, op, rhs );
    }

    return lhs;
}
</code></pre><p>Now that we have mutable variables and assignment we can mutate loop variables or input parameters. For example:</p>
<pre><code class="lang-Kaleidoscope"># Function to print a double.
extern printd(x);

# Define &#39;:&#39; for sequencing: as a low-precedence operator that ignores operands
# and just returns the RHS.
def binary : 1 (x y) y;

def test(x)
  printd(x) :
  x = 4 :
  printd(x);

test(123);
</code></pre><p>When run, this prints <code>1234</code> and <code>4</code>, showing that the value was mutated as, expected.</p>
<h2 id="user-defined-local-variables">User-defined Local Variables</h2>
<p>As described in the general syntax discussion of the Kaleidoscope language <a href="Kaleidoscope-ch2.html#varinexpression">VarInExpression</a>
the VarIn expression is used to declare local variables for a scope. A few changes are
required to support this language construct.</p>
<h3 id="add-visitvarinexpression">Add VisitVarInExpression</h3>
<p>The VarIn expression visitor needs to handle the mutability of the scoped variables.
The basic idea for each VarIn expression is to push a new scope on the scope stack then walk through all the
variables in the expression to define them and emit the expression for the initializer. After all the values
are defined the child expression &quot;scope&quot; is emitted, which may contain another VarIn or loop expression. Once
the emit completes, the variable scope is popped from the stack to restore back the previous level.</p>
<pre><code class="lang-csharp" name="VisitVarInExpression">public override Value VisitVarInExpression( [NotNull] VarInExpressionContext context )
{
    using( NamedValues.EnterScope( ) )
    {
        Function function = InstructionBuilder.InsertBlock.ContainingFunction;
        foreach( var initializer in context.Initiaizers )
        {
            Value initValue = Context.CreateConstant( 0.0 );
            if( initializer.Value != null )
            {
                initValue = initializer.Value.Accept( this );
            }

            var alloca = CreateEntryBlockAlloca( function, initializer.Name );
            InstructionBuilder.Store( initValue, alloca );
            NamedValues[ initializer.Name ] = alloca;
        }

        return context.Scope.Accept( this );
    }
}
</code></pre><h2 id="conclusion">Conclusion</h2>
<p>This completes the updates needed to support mutable variables with potentially nested scopes. All of this without
needing to manually deal with PHI nodes or generate SSA form!</p>
</article>
          </div>
          <div class="contribution-panel mobile-hide">
              <a href="https://github.com/UbiquityDotNET/Llvm.NET/blob/master/docfx/articles/Samples/Kaleidoscope-ch7.md/#L1" title="Improve this Doc" class="fab btn-warning pull-right"><i class="glyphicon glyphicon-pencil"></i></a>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            Copyright (C) 2017, Dot NET Foundation<br><strong>Build:</strong> 5.0.1-alpha--ci-BLD.437223788
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
