<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Implementing the parser | Llvm.NET </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Implementing the parser | Llvm.NET ">
    <meta name="generator" content="docfx 2.29.1.0">
    
    <link rel="shortcut icon" href="../../favicon.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <meta property="docfx:navrel" content="../../toc">
    <meta property="docfx:tocrel" content="toc">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../DragonSharp48x48.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
                <ul class="nav level1 navbar-nav">
                  <li class="">
                    <a href="../../api/index.html" title="API Documentation" class="">API Documentation</a>
                  </li>
                  <li class="">
                    <a href="../../articles/index.html" title="Articles" class="">Articles</a>
                  </li>
                  <li class="">
                    <a href="http://LLVM.org" title="LLVM.org" class="">LLVM.org</a>
                  </li>
                  <li class="">
                    <a href="http://releases.llvm.org/5.0.0/docs/index.html" title="LLVM Docs" class="">LLVM Docs</a>
                  </li>
                </ul>
            </div>
          </div>
        </nav>
      </header>
      <div role="main" class="container body-content hide-when-search">
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div>
              <div class="sidefilter">
                <form class="toc-filter">
                  <span class="glyphicon glyphicon-filter filter-icon"></span>
                  <input type="text" id="toc_filter_input" placeholder="Enter here to filter..." onkeypress="if(event.keyCode==13) {return false;}">
                </form>
              </div>
              <div class="sidetoc">
                <div class="toc" id="toc">
                  
                  <ul class="nav level1">
                    <li class="">
                      <a href="codegeneration.html" title="Code Generation" class="">Code Generation</a>
                    </li>
                    <li class="">
                      <span class="expand-stub"></span>
                      <a href="Kaleidoscope.html" title="Kaleidoscope" class="">Kaleidoscope</a>
                        
                        <ul class="nav level2">
                          <li class="active">
                            <a href="Kaleidoscope-ch2.html" title="Chapter 2" class="active">Chapter 2</a>
                          </li>
                          <li class="">
                            <a href="Kaleidoscope-ch3.html" title="Chapter 3" class="">Chapter 3</a>
                          </li>
                          <li class="">
                            <a href="Kaleidoscope-ch4.html" title="Chapter 4" class="">Chapter 4</a>
                          </li>
                          <li class="">
                            <a href="Kaleidoscope-ch5.html" title="Chapter 5" class="">Chapter 5</a>
                          </li>
                          <li class="">
                            <a href="Kaleidoscope-ch6.html" title="Chapter 6" class="">Chapter 6</a>
                          </li>
                          <li class="">
                            <a href="Kaleidoscope-ch7.html" title="Chapter 7" class="">Chapter 7</a>
                          </li>
                          <li class="">
                            <a href="Kaleidoscope-ch8.html" title="Chapter 8" class="">Chapter 8</a>
                          </li>
                          <li class="">
                            <a href="Kaleidoscope-ch9.html" title="Chapter 9" class="">Chapter 9</a>
                          </li>
                        </ul>  </li>
                  </ul>        </div>
              </div>
            </div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="implementing-the-parser">Implementing the parser</h1>

<p>The Lllvm.NET version of Kaleidoscope leverages ANTLR4 to parse the langague into a parse tree.
The chapter 2 sample doesn&#39;t actually generate any code. Instead it focuses on the general structure
of the samples and parsing of the language. The sample for this chapter enables all language features
to allow exploring the language and how it is parsed to help better understand the rest of the chapters
better. It is hoped that users of this library find this helpful as understanding the language grammar
from reading the LVM tutorials and source was a difficult task since it isn&#39;t formally defined in one
place. (There are some EBNF like comments in the code but it is spread around without much real discussion
of the lanbguage the tutorials guide you to implement)</p>
<h2 id="formal-grammar">Formal Grammar</h2>
<h3 id="lexer-symbols">Lexer symbols</h3>
<p>The Kaleidoscope lexer consists of several tokens and is defined in the Kaleidoscope.g4 grammar file</p>
<pre><code class="lang-antlr">// Lexer Rules -------
fragment NonZeroDecimalDigit_: [1-9];
fragment DecimalDigit_: [0-9];
fragment Digits_: &#39;0&#39; | [1-9][0-9]*;
fragment EndOfFile_: &#39;\u0000&#39; | &#39;\u001A&#39;;
fragment EndOfLine_
    : (&#39;\r&#39; &#39;\n&#39;)
    | (&#39;\r&#39; |&#39;\n&#39; | &#39;\u2028&#39; | &#39;\u2029&#39;)
    | EndOfFile_
    ;

LPAREN: &#39;(&#39;;
RPAREN: &#39;)&#39;;
COMMA: &#39;,&#39;;
SEMICOLON: &#39;;&#39;;
DEF: &#39;def&#39;;
EXTERN: &#39;extern&#39;;

ASSIGN:&#39;=&#39;;
ASTERISK: &#39;*&#39;;
PLUS: &#39;+&#39;;
MINUS:&#39;-&#39;;
LEFTANGLE: &#39;&lt;&#39;;
SLASH: &#39;/&#39;;

EXCLAMATION: &#39;!&#39;;
PERCENT: &#39;%&#39;;
AMPERSAND:&#39;&amp;&#39;;
PERIOD:&#39;.&#39;;
COLON: &#39;:&#39;;
RIGHTANGLE: &#39;&gt;&#39;;
QMARK: &#39;?&#39;;
ATSIGN: &#39;@&#39;;
BACKSLASH: &#39;\\&#39;;
CARET: &#39;^&#39;;
UNDERSCORE: &#39;_&#39;;
VBAR: &#39;|&#39;;
EQUALEQUAL: &#39;==&#39;;
NOTEQUAL: &#39;!=&#39;;
PLUSPLUS: &#39;++&#39;;
MINUSMINUS: &#39;--&#39;;

IF:     {FeatureControlFlow}? &#39;if&#39;;
THEN:   {FeatureControlFlow}? &#39;then&#39;;
ELSE:   {FeatureControlFlow}? &#39;else&#39;;
FOR:    {FeatureControlFlow}? &#39;for&#39;;
IN:     {FeatureControlFlow}? &#39;in&#39;;
VAR:    {FeatureMutableVars}? &#39;var&#39;;
UNARY:  {FeatureUserOperators}? &#39;unary&#39;;
BINARY: {FeatureUserOperators}? &#39;binary&#39;;

LineComment: &#39;#&#39; ~[\r\n]* EndOfLine_ -&gt; skip;
WhiteSpace: [ \t\r\n\f]+ -&gt; skip;

Identifier: [a-zA-Z][a-zA-Z0-9]*;
Number: Digits_ (&#39;.&#39; DecimalDigit_+)?;
</code></pre><p>This includes basic numeric patterns as well as Identifiers and the symbols allowed for operators and keywords
for the language. Subsequent chapters will introduce the meaning and use of each of these.</p>
<h4 id="language-feature-defined-keywords">Language Feature Defined Keywords</h4>
<p>Chapters 5-7 each introduce new language features that introduce new keywords into the language. In order to
maintain a single grammar for all chapters the lexer uses a technique of ANTLR4 called semantic predicates.
These are basically boolean expressions that determine if a given rule should be applied. These are applied
to the rules for the feature specific keywords. Thus, at runtime, if a given feature is disabled then the
keyword is not recognized.</p>
<pre><code class="lang-antlr">IF:     {FeatureControlFlow}? &#39;if&#39;;
THEN:   {FeatureControlFlow}? &#39;then&#39;;
ELSE:   {FeatureControlFlow}? &#39;else&#39;;
FOR:    {FeatureControlFlow}? &#39;for&#39;;
IN:     {FeatureControlFlow}? &#39;in&#39;;
VAR:    {FeatureMutableVars}? &#39;var&#39;;
UNARY:  {FeatureUserOperators}? &#39;unary&#39;;
BINARY: {FeatureUserOperators}? &#39;binary&#39;;
</code></pre><div class="NOTE"><h5>Note</h5><p>There are some important distinctions in the Llvm.NET implementation of Kaleidoscope, in the operators allowed for
User defined operators. The official LLVM version allows definining an operator &#39;=&#39;, (in chapter 6). However,
in Chapter 7, when Mutable variables are introduced the &#39;=&#39; is reserved by the language for assignment. Thus,
any code written for chapter 6 with a user defined &#39;=&#39; operator would not work in later versions. Thus, the
Llvm.NET version reserves the &#39;=&#39; in all versions, but allows the &#39;==&#39; operator. (It also adds the &#39;++&#39; and &#39;--&#39;
tokens as user operators [The official LLVM implementation only allows a single character as the operator lexeme])</p>
<p>Additionally the Llvm.NET implementation adds the built-in &#39;^&#39; operator for exponentiation.</p>
</div>
<h3 id="parser">Parser</h3>
<p>The parser, like the lexer, uses Semantic Predicates, that allows for dynamic adaptation of the grammar
and parser to handle variations or versions of the language. The Sample code uses that to selectively enable
language features as the chapters progress, without needing to change the grammar or generated parser code.
The parser code provides a simple means of expressing the language support level. Semantic predicates play
a vital role in supporting user defined operators with user defined precedence.</p>
<h4 id="parser-grammar">Parser grammar</h4>
<p>A full tutorial on ANTLR is beyond the scope of this article but the basics should be familiar
enough to anyone acquainted with EBNF form to make enough sense out of it. Don&#39;t worry too much
about the details at this point as subsequent chapters will cover salient points as new features
are enabled.</p>
<h5 id="operators">Operators</h5>
<p>In order to support the parser detecting attemtps to overload builtin operators and to handle the fact that some
operators don&#39;t make any sense for unary operators (e.g. you can&#39;t create a user defined unary &#39;=&#39; operator. technically
you could implement that but it would make for some confusing code. If you really like hard to read and comprehend code
there are <a href="https://en.wikipedia.org/wiki/Brainfuck">other languages</a> better suited to that end 8^) )</p>
<p>To manage detection of appropriate operator tokens the grammar uses a set of parser rules that group the operator
tokens by their allowed kinds. This allows subsequent rules to simply refer to the kind of operator expected and
not worry about the actual tokens involved. It also allows the parser to detect syntax and useage errors like
trying to create a user defined &#39;+&#39; operator.</p>
<pre><code class="lang-antlr">// built-in operator symbols
builtinop
    : ASSIGN
    | ASTERISK
    | PLUS
    | MINUS
    | SLASH
    | LEFTANGLE
    | CARET
    ;

// Allowed user defined binary symbols
userdefinedop
    : EXCLAMATION
    | PERCENT
    | AMPERSAND
    | PERIOD
    | COLON
    | RIGHTANGLE
    | QMARK
    | ATSIGN
    | BACKSLASH
    | UNDERSCORE
    | VBAR
    | EQUALEQUAL
    | NOTEQUAL
    | PLUSPLUS
    | MINUSMINUS
    ;

// unary ops can re-use built-in binop symbols (Except ASSIGN)
unaryop
    : ASTERISK
    | PLUS
    | MINUS
    | SLASH
    | LEFTANGLE
    | CARET
    | EXCLAMATION
    | PERCENT
    | AMPERSAND
    | PERIOD
    | COLON
    | RIGHTANGLE
    | QMARK
    | ATSIGN
    | BACKSLASH
    | UNDERSCORE
    | VBAR
    | EQUALEQUAL
    | NOTEQUAL
    | PLUSPLUS
    | MINUSMINUS
    ;

// All binary operators
binaryop
    : ASSIGN
    | ASTERISK
    | PLUS
    | MINUS
    | SLASH
    | LEFTANGLE
    | CARET
    | EXCLAMATION
    | PERCENT
    | AMPERSAND
    | PERIOD
    | COLON
    | RIGHTANGLE
    | QMARK
    | ATSIGN
    | BACKSLASH
    | UNDERSCORE
    | VBAR
    | EQUALEQUAL
    | NOTEQUAL
    | PLUSPLUS
    | MINUSMINUS
    ;
</code></pre><h5 id="initializers">Initializers</h5>
<p>Initializers are a useful re-useable rule to handle a common sequence in the language in multiple different contexts.
(sort of like a function in most programming languages, in fact, ANTLR rules are implemented in the generated parser
as methods). </p>
<pre><code class="lang-antlr">// pull the initializer out to a distinct rule so it is easier to get at
// the list of initializers when walking the parse tree
initializer
    : Identifier (ASSIGN expression[0])?
    ;
</code></pre><h5 id="primary-expressions-atoms">Primary Expressions (Atoms)</h5>
<p>There are a number of primary expressions (also known as &#39;Atoms&#39;) that are not left recursive in their definition.
These are split out to a distinct rule to aid in the support of left recursion and the need for user defined operator
precedence.</p>
<pre><code class="lang-antlr">// Non Left recursive expressions (a.k.a. atoms)
primaryExpression
    : LPAREN expression[0] RPAREN                                                 # ParenExpression
    | Identifier LPAREN (expression[0] (COMMA expression[0])*)? RPAREN            # FunctionCallExpression
    | VAR initializer (COMMA initializer)* IN expression[0]                       # VarInExpression
    | IF expression[0] THEN expression[0] ELSE expression[0]                      # ConditionalExpression
    | FOR initializer COMMA expression[0] (COMMA expression[0])? IN expression[0] # ForExpression
    | {IsPrefixOp()}? unaryop expression[0]                                       # UnaryOpExpression
    | Identifier                                                                  # VariableExpression
    | Number                                                                      # ConstExpression
    ;
</code></pre><p>Let&#39;s look at each of these in turn to get a better understanding of the language.</p>
<h6 id="parenexpression">ParenExpression</h6>
<pre><code class="lang-antlr">LPAREN expression[0] RPAREN
</code></pre><p>This is a simple rule for sub-expressions within parenthesis for example: <code>(1+2)/3</code> the parenthesis groups the
addition so that it occurs before the division since, normally the precedence of division is higher. The parse
tree for that expression looks like this:</p>
<p><img src="parsetree-paren-expr.svg" alt="Parse Tree"></p>
<h6 id="functioncallexpression">FunctionCallExpression</h6>
<pre><code class="lang-antlr">Identifier LPAREN (expression[0] (COMMA expression[0])*)? RPAREN
</code></pre><p>This rule covers a function call which can have 0 or more comma delimited arguments. The parse tree
for the call <code>foo(1, 2, 3);</code> is:</p>
<p><img src="parsetree-func-call.svg" alt="Parse Tree"></p>
<h6 id="other-expressions">Other expressions</h6>
<p>The other expressions are either simple tokens like <code>Identifier</code> and <code>Number</code> or more complex expressions that are
covered in detail in later chapters.</p>
<h4 id="parse-tree">Parse Tree</h4>
<p>The Llvm.NET implementation of Kaleidoscope doesn&#39;t use an AST per se. Instead it use the parse tree generated
by ANTLR with the addition of C# partial classes. ANTLR will generate a parser based on the grammar description
input file. This generated parser (and lexer) includes a context type for each rule of the grammar. The C# target
for ANTLR generates these types as partial classes so the they are extensible from the parser assembly without
needing to derive a new type or use virtuals etc. Thus, the Kaleidoscope.Grammar assembly contains partial class
extensions that provide simpler property accessors and support methods to where an additional AST is not needed.
(e.g. The parse tree is the AST)</p>
<p>See <a href="Kaleidoscope-Parsetree-examples.html">Kaleidoscope Parse Tree Examples</a> for more information and example
diagrams of the parse tree for various language constructs.</p>
<h2 id="basic-application-architecture">Basic Application Architecture</h2>
<p>Generally speaking there are three main components to all of the sample chapter applications.</p>
<ol>
<li>The main driver application (e.g. program.cs)</li>
<li>The parser (e.g. Kaleidoscope.Grammar assembly)</li>
<li>The code generator (e.g. CodeGenerator.cs)</li>
</ol>
<p>There is an additional utility support library Kaleidoscope.Runtime providing some common adapter/facade pattern
implementations for working with Kaleidoscope, ANTLR and Llvm.NET.</p>
<h3 id="driver">Driver</h3>
<p>While each chapter is a bit different from the others. Many of the chapters are virtually identical for the driver.
In particular Chapters 3-7 only really differ in the language level support. </p>
<pre><code class="lang-csharp" name="Program.cs">// &lt;copyright file=&quot;Program.cs&quot; company=&quot;.NET Foundation&quot;&gt;
// Copyright (c) .NET Foundation. All rights reserved.
// &lt;/copyright&gt;

using System;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using Kaleidoscope.Grammar;
using Kaleidoscope.Runtime;
using Llvm.NET.Values;

using static Kaleidoscope.Runtime.Utilities;
using static Llvm.NET.StaticState;

[assembly: SuppressMessage( &quot;StyleCop.CSharp.DocumentationRules&quot;, &quot;SA1652:Enable XML documentation output&quot;, Justification = &quot;Sample application&quot; )]

namespace Kaleidoscope
{
    public static class Program
    {
        /// &lt;summary&gt;C# version of the LLVM Kaleidoscope language tutorial&lt;/summary&gt;
        /// &lt;param name=&quot;args&quot;&gt;Ignored...&lt;/param&gt;
        [SuppressMessage( &quot;Redundancies in Symbol Declarations&quot;, &quot;RECS0154:Parameter is never used&quot;, Justification = &quot;Standard required signature&quot; )]
        public static void Main( string[ ] args )
        {
            WaitForDebugger( );

            using( InitializeLLVM( ) )
            {
                RegisterNative( );
                var parser = new ReplParserStack( LanguageLevel.SimpleExpressions );
                using( var generator = new CodeGenerator( parser.GlobalState ) )
                {
                    Console.WriteLine( &quot;LLVM Kaleidoscope Interpreter - {0}&quot;, parser.LanguageLevel );

                    var replLoop = new ReplLoop&lt;Value&gt;( generator, parser );
                    replLoop.ReadyStateChanged += ( s, e ) =&gt; Console.Write( e.PartialParse ? &quot;&gt;&quot; : &quot;Ready&gt;&quot; );
                    replLoop.GeneratedResultAvailable += OnGeneratedResultAvailable;

                    replLoop.Run( );
                }
            }
        }

        private static void OnGeneratedResultAvailable( object sender, GeneratedResultAvailableArgs&lt;Value&gt; e )
        {
            var source = ( ReplLoop&lt;Value&gt; )sender;

            switch( e.Result )
            {
            case ConstantFP result:
                Console.WriteLine( &quot;Evaluated to {0}&quot;, result.Value );
                break;

            case Function function:
                if( source.AdditionalDiagnostics.HasFlag( DiagnosticRepresentations.LlvmIR ) )
                {
                    function.ParentModule.WriteToTextFile( Path.ChangeExtension( GetSafeFileName( function.Name ), &quot;ll&quot; ), out string ignoredMsg );
                }

                Console.WriteLine( &quot;Defined function: {0}&quot;, function.Name );
                break;
            }
        }
    }
}
</code></pre><p>The Main function starts out by calling WaitForDebugger(). This is a useful utility that doesn&#39;t do anything in a
release build, but in debug builds will check for an attached debugger and if none is found it will wait for one.
This works around a missing feauture of the .NET Standard C# project system that does not support launching mixed
native+managed debugging. When you need to go all the way into debugging the LLVM code, you can launch the debug
version of the app without debugging, then attach to it and select native and managed debugging. (Hopefully this
feature will be restored to these projects in the future so this trick isn&#39;t needed...)</p>
<p>The real heart of the driver app is in the next small block of code. The driver begins by initializing the LLVM
system, which loads the correct platform architecture version of the LibLLVM.DLL and initializes a number of
internal LLVM static infrastructure. This requires some teardown for a clean shutdown of LLVM so the initialization
returns an IDisposable which requires a call to Dispose() to cleanup. The cleanup is handled automatically via a
C# using statement.</p>
<pre><code class="lang-C#">using( InitializeLLVM( ) )
{
[...]
}
</code></pre><p>The next step of initialization for LLVM is registration of platform targets. Since LLVM can target multiple different
platforms, and support for each target requires some resources applications need to declare the targets they want to use.
For the JIT Kaleidoscope samples the target is the native host system so that is the only target registered.</p>
<p>Once LLVM is initialized the Kaleidoscope parser is created. The ReplParserStack contains the support for parsing the
Kaleidoscope language from the REPL loop interactive input. The stakc also maintains the global state of the runtime,
which controls the language features enabled, and if user defined operators are enabled, contains the operators defined
along with their precednece.</p>
<pre><code class="lang-C#">var parser = new ReplParserStack( LanguageLevel.SimpleExpressions );
</code></pre><p>After the parser is created the code generator is constructed. The code generator is responsible for most of the real work
of the language. The implementation of the generator is different for each chapter. Howver, since the generator is based
on the ANTLR4 generated KaleidoscopeParserListener (using a visitor pattern), and the chapters build on one another, for
the most part, it is fairly easy to diff the generators for each chapter to see the changes needed to introduce the feauture
the chapter introduces. Each chapter will go into more details on this. Since the generator usually allocates resources in
Llvm.NET it implements IDisposable to ensure they are released as early as possible.</p>
<pre><code class="lang-C#">using( var generator = new CodeGenerator( parser.GlobalState ) )
{
}
</code></pre><p>Inside the using statement for the code generator is the core loop for the language runtime. This starts by displaying
a brief &quot;hello&quot; message indicating the nature of the app and the language level supported. The actual REPL loop is handled
via a common library class <code>ReplLoop&lt;T&gt;</code> (in Kaleidoscope.Runtime) this class handles retieving text from an input source
(default is Console.In) and producing a complete &quot;statement&quot; for parsings. (Technically speaking Kaleidoscope doesn&#39;t have
statements but to allow a user to type <code>[...] a+b&lt;newline&gt;+c</code>) without processing that as two expression invovations a 
semicolon is used to convey the user&#39;s intent that the code is complete and ready for evaluation. The ReplLoop class takes
care of this in a generalized manner. The ReplLoop can consume input from any <code>System.TextReader</code> and uses <code>System.Console.In</code>
as a default. When the loop detects a new line that doesn&#39;t have a semicolon it will generate a Ready state changed event
so the calling application can inform the user with a different prompt (in all the Llvm.NET samples this is &#39;&gt;&#39;). Once a complete
expression is available, the loop will submit it to the parser to generate a parse tree. The loop then passes the parse tree
and the parser that created it to the generators Generate() method to actually generate the result. The result type of the
generator is the generic type parameter for <code>ReplLoop&lt;T&gt;</code> as the loop class doesn&#39;t need to use the result itself. The
loop will trigger the GeneratedResultAvailable event to allow the driver application to do whatever it wants with the results.</p>
<p>The calling application will generally hook an event handler to show the results of the generation in some fashion. For the
basic samples (Chapter 3-7) it indicates the value of any JITed and executed top level expressions, or the name of any functions
defined. Chapter 2 has additional support for showing an XML representation of the tree but the same basic pattern applies.
This, helps to keep the samples consistent and as similar as possible to allow diffs to focus on the changes for a particular
feature. The separation of concerns also aids in making the grammar, runtime and code generation unit-testable without the
driver. (Although that isn&#39;t implemented yet it is intended for the future to help broaden testing of Llvm.NET to more scenarios
and catch breaking issues quicker.)</p>
<pre><code class="lang-C#">private static void OnGeneratedResultAvailable( object sender, GeneratedResultAvailableArgs&lt;Value&gt; e )
{
    var source = ( ReplLoop&lt;Value&gt; )sender;

    switch( e.Result )
    {
    case ConstantFP result:
        Console.WriteLine( &quot;Evaluated to {0}&quot;, result.Value );
        break;

    case Function function:
        if( source.AdditionalDiagnostics.HasFlag( DiagnosticRepresentations.LlvmIR ) )
        {
            function.ParentModule.WriteToTextFile( Path.ChangeExtension( GetSafeFileName( function.Name ), &quot;ll&quot; ), out string ignoredMsg );
        }

        Console.WriteLine( &quot;Defined function: {0}&quot;, function.Name );
        break;
    }
}
</code></pre><h3 id="special-case-for-chapter-2">Special case for Chapter 2</h3>
<p>Chapter 2 sample code, while still following the general patterns, is a bit unique, it doesn&#39;t use Lllvm.NET at all. It
is only focused on the language and parsing. This helps in understanding the basic patterns of the code and support and
serves as an aid in understanding the language itself. Of particular use is the support for generating DGML and
<a href="http://blockdiag.com">blockdiag</a> representations of the parse tree for a given parse (All of the diagrams in these tutorials
were created by creating the blockdiag files and then generating the SVG files from that). Having a nice visual
representation of a parser tree result is helpful to understanding the parsing and various parse tree node types.</p>
<p>The visual graph is also immensensly valuable when making changes to the grammar so you can see the results of a parse and
more readily understand why something isn&#39;t right. (In fact this feature was enabled to track down bugs in the parsing for
user defined operator precedence that was difficult to figure out. Once the visualization was available it became quite easy
to see the problems). Thus, Chapter 2 is both a simple introductory example and tool for use when doing advanced language
tweaking.</p>
</article>
          </div>
          <div class="contribution-panel mobile-hide">
              <a href="https://github.com/UbiquityDotNET/Llvm.NET/blob/master/docfx/articles/Samples/Kaleidoscope-ch2.md/#L1" title="Improve this Doc" class="fab btn-warning pull-right"><i class="glyphicon glyphicon-pencil"></i></a>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            Copyright (C) 2017, Dot NET Foundation
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
