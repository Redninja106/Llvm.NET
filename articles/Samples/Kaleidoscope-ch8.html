<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>8. Kaleidoscope: Compiling to Object Code | Llvm.NET </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="8. Kaleidoscope: Compiling to Object Code | Llvm.NET ">
    <meta name="generator" content="docfx 2.33.0.0">
    
    <link rel="shortcut icon" href="../../favicon.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <meta property="docfx:navrel" content="../../toc">
    <meta property="docfx:tocrel" content="toc">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../DragonSharp48x48.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
                <ul class="nav level1 navbar-nav">
                  <li class="">
                    <a href="../../api/index.html" title="API Documentation" class="">API Documentation</a>
                  </li>
                  <li class="">
                    <a href="../../articles/index.html" title="Articles" class="">Articles</a>
                  </li>
                  <li class="">
                    <a href="https://github.com/UbiquityDotNET/Llvm.NET" title="GitHub Repository" class="">GitHub Repository</a>
                  </li>
                  <li class="">
                    <a href="http://LLVM.org" title="LLVM.org" class="">LLVM.org</a>
                  </li>
                  <li class="">
                    <a href="http://releases.llvm.org/5.0.1/docs/index.html" title="LLVM Docs" class="">LLVM Docs</a>
                  </li>
                </ul>
            </div>
          </div>
        </nav>
      </header>
      <div role="main" class="container body-content hide-when-search">
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div>
              <div class="sidefilter">
                <form class="toc-filter">
                  <span class="glyphicon glyphicon-filter filter-icon"></span>
                  <input type="text" id="toc_filter_input" placeholder="Enter here to filter..." onkeypress="if(event.keyCode==13) {return false;}">
                </form>
              </div>
              <div class="sidetoc">
                <div class="toc" id="toc">
                  
                  <ul class="nav level1">
                    <li class="">
                      <span class="expand-stub"></span>
                      <a class="">Code Generation</a>
                        
                        <ul class="nav level2">
                          <li class="">
                            <a href="codegeneration.html" title="CodeGenerator With Debug Information" class="">CodeGenerator With Debug Information</a>
                          </li>
                        </ul>  </li>
                    <li class="">
                      <span class="expand-stub"></span>
                      <a class="">Kaleidoscope</a>
                        
                        <ul class="nav level2">
                          <li class="">
                            <a href="Kaleidoscope.html" title="Chapter 1 - Language Introduction" class="">Chapter 1 - Language Introduction</a>
                          </li>
                          <li class="">
                            <a href="Kaleidoscope-ch2.html" title="Chapter 2 - Implementing the parser" class="">Chapter 2 - Implementing the parser</a>
                          </li>
                          <li class="">
                            <a href="Kaleidoscope-ch3.html" title="Chapter 3 - Generating LLVM IR" class="">Chapter 3 - Generating LLVM IR</a>
                          </li>
                          <li class="">
                            <a href="Kaleidoscope-ch4.html" title="Chapter 4 - JIT and Optimizer Support" class="">Chapter 4 - JIT and Optimizer Support</a>
                          </li>
                          <li class="">
                            <a href="Kaleidoscope-ch5.html" title="Chapter 5 - Control Flow" class="">Chapter 5 - Control Flow</a>
                          </li>
                          <li class="">
                            <a href="Kaleidoscope-ch6.html" title="Chapter 6 - User Defined Operators" class="">Chapter 6 - User Defined Operators</a>
                          </li>
                          <li class="">
                            <a href="Kaleidoscope-ch7.html" title="Chapter 7 - Mutable Variables" class="">Chapter 7 - Mutable Variables</a>
                          </li>
                          <li class="active">
                            <a href="Kaleidoscope-ch8.html" title="Chapter 8 - AOT Compilation" class="active">Chapter 8 - AOT Compilation</a>
                          </li>
                          <li class="">
                            <a href="Kaleidoscope-ch9.html" title="Chapter 9 - Debug Information" class="">Chapter 9 - Debug Information</a>
                          </li>
                          <li class="">
                            <a href="Kaleidoscope-ParseTreeVisitor.html" title="ParseTree Visitor" class="">ParseTree Visitor</a>
                          </li>
                          <li class="">
                            <a href="Kaleidoscope-Parsetree-examples.html" title="ParseTree Examples" class="">ParseTree Examples</a>
                          </li>
                        </ul>  </li>
                  </ul>        </div>
              </div>
            </div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="8-kaleidoscope-compiling-to-object-code">8. Kaleidoscope: Compiling to Object Code</h1>

<p>This tutorial describes how to adapt the Kaleidoscope JIT engine into an Ahead of Time (AOT) compiler
by generating target specific native object files.</p>
<h2 id="choosing-a-target">Choosing a target</h2>
<p>LLVM has built-in support for cross-compilation. This allows compiling to the architecture of the platform
you run the compiler on or, just as easily, for some other architecture. For the Kaleidoscope tutorial we&#39;ll
focus on just the native target the compiler is running on.</p>
<p>LLVM uses a &quot;Triple&quot; string to describe the target used for code generation. This takes the form <code>&lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;</code>
(see the description of the <a class="xref" href="../../api/Llvm.NET.Triple.html">Triple</a> type for more details)</p>
<p>Fortunately, it is normally not required to build such strings directly. </p>
<h2 id="code-generation-changes">Code Generation Changes</h2>
<p>The changes in code generation are fairly straight forward and consist of the following basic steps.</p>
<ol>
<li>Remove JIT engine support</li>
<li>Expose the bit code module generated, so it is available to the &quot;driver&quot;.</li>
<li>Saving the target machine (since it doesn&#39;t come from the JIT anymore)</li>
</ol>
<p>The changes are shown below in classic &#39;diff&#39; form since each change doesn&#39;t really need a detailed explanation.
(Nothing even remotely close to &quot;Rocket Science&quot; here. 8^) )</p>
<pre><code class="lang-diff">diff --git a/Samples/Kaleidoscope/Chapter7/CodeGenerator.cs b/Samples/Kaleidoscope/Chapter8/CodeGenerator.cs
index 89e9b2ad8..1e7597c78 100644
--- a/Samples/Kaleidoscope/Chapter7/CodeGenerator.cs
+++ b/Samples/Kaleidoscope/Chapter8/CodeGenerator.cs
@@ -3,9 +3,7 @@
 // &lt;/copyright&gt;

 using System;
-using System.Collections.Generic;
 using System.Linq;
-using System.Runtime.InteropServices;
 using Antlr4.Runtime;
 using Antlr4.Runtime.Misc;
 using Antlr4.Runtime.Tree;
@@ -13,7 +11,6 @@ using Kaleidoscope.Grammar;
 using Kaleidoscope.Runtime;
 using Llvm.NET;
 using Llvm.NET.Instructions;
-using Llvm.NET.JIT;
 using Llvm.NET.Transforms;
 using Llvm.NET.Values;

@@ -30,24 +27,24 @@ namespace Kaleidoscope
         , IKaleidoscopeCodeGenerator&lt;Value&gt;
     {
         // &lt;Initialization&gt;
-        public CodeGenerator( DynamicRuntimeState globalState )
+        public CodeGenerator( DynamicRuntimeState globalState, TargetMachine machine )
         {
             RuntimeState = globalState;
             Context = new Context( );
-            JIT = new KaleidoscopeJIT( );
+            TargetMachine = machine;
             InitializeModuleAndPassManager( );
             InstructionBuilder = new InstructionBuilder( Context );
             FunctionPrototypes = new PrototypeCollection( );
-            FunctionModuleMap = new Dictionary&lt;string, IJitModuleHandle&gt;( );
             NamedValues = new ScopeStack&lt;Alloca&gt;( );
         }
         // &lt;/Initialization&gt;

         public bool DisableOptimizations { get; set; }

+        public BitcodeModule Module { get; private set; }
+
         public void Dispose( )
         {
-            JIT.Dispose( );
             Context.Dispose( );
         }

@@ -112,23 +109,18 @@ namespace Kaleidoscope
         {
             return DefineFunction( ( Function )context.Signature.Accept( this )
                                  , context.BodyExpression
-                                 ).Function;
+                                 );
         }
         // &lt;/VisitFunctionDefinition&gt;

         // &lt;VisitTopLevelExpression&gt;
         public override Value VisitTopLevelExpression( [NotNull] TopLevelExpressionContext context )
         {
-            var proto = new Prototype( $&quot;anon_expr_{AnonNameIndex++}&quot; );
-            var function = GetOrDeclareFunction( proto, isAnonymous: true );
-
-            var (_, jitHandle) = DefineFunction( function, context.expression( ) );
+            var function = GetOrDeclareFunction( new Prototype( $&quot;anon_expr_{AnonNameIndex++}&quot; )
+                                               , isAnonymous: true
+                                               );

-            var nativeFunc = JIT.GetDelegateForFunction&lt;AnonExpressionFunc&gt;( proto.Identifier.Name );
-            var retVal = Context.CreateConstant( nativeFunc( ) );
-            FunctionModuleMap.Remove( function.Name );
-            JIT.RemoveModule( jitHandle );
-            return retVal;
+            return DefineFunction( function, context.expression( ) );
         }
         // &lt;/VisitTopLevelExpression&gt;

@@ -452,7 +444,8 @@ namespace Kaleidoscope
         private void InitializeModuleAndPassManager( )
         {
             Module = Context.CreateBitcodeModule( );
-            Module.Layout = JIT.TargetMachine.TargetData;
+            Module.TargetTriple = TargetMachine.Triple;
+            Module.Layout = TargetMachine.TargetData;
             FunctionPassManager = new FunctionPassManager( Module );
             FunctionPassManager.AddPromoteMemoryToRegisterPass( )
                                .AddInstructionCombiningPass( )
@@ -514,25 +507,13 @@ namespace Kaleidoscope
         // &lt;/GetOrDeclareFunction&gt;

         // &lt;DefineFunction&gt;
-        private (Function Function, IJitModuleHandle JitHandle) DefineFunction( Function function, ExpressionContext body )
+        private Function DefineFunction( Function function, ExpressionContext body )
         {
             if( !function.IsDeclaration )
             {
                 throw new CodeGeneratorException( $&quot;Function {function.Name} cannot be redefined in the same module&quot; );
             }

-            // Destroy any previously generated module for this function.
-            // This allows re-definition as the new module will provide the
-            // implementation. This is needed, otherwise both the MCJIT
-            // and OrcJit engines will resolve to the original module, despite
-            // claims to the contrary in the official tutorial text. (Though,
-            // to be fair it may have been true in the original JIT and might
-            // still be true for the interpreter)
-            if( FunctionModuleMap.Remove( function.Name, out IJitModuleHandle handle ) )
-            {
-                JIT.RemoveModule( handle );
-            }
-
             var basicBlock = function.AppendBasicBlock( &quot;entry&quot; );
             InstructionBuilder.PositionAtEnd( basicBlock );
             using( NamedValues.EnterScope( ) )
@@ -548,7 +529,7 @@ namespace Kaleidoscope
                 if( funcReturn == null )
                 {
                     function.EraseFromParent( );
-                    return (null, default);
+                    return null;
                 }

                 InstructionBuilder.Return( funcReturn );
@@ -560,10 +541,7 @@ namespace Kaleidoscope
                 FunctionPassManager.Run( function );
             }

-            var jitHandle = JIT.AddModule( Module );
-            FunctionModuleMap.Add( function.Name, jitHandle );
-            InitializeModuleAndPassManager( );
-            return (function, jitHandle);
+            return function;
         }
         // &lt;/DefineFunction&gt;

@@ -585,18 +563,11 @@ namespace Kaleidoscope
         private readonly DynamicRuntimeState RuntimeState;
         private static int AnonNameIndex;
         private readonly Context Context;
-        private BitcodeModule Module;
         private readonly InstructionBuilder InstructionBuilder;
         private readonly ScopeStack&lt;Alloca&gt; NamedValues;
-        private readonly KaleidoscopeJIT JIT;
-        private readonly Dictionary&lt;string, IJitModuleHandle&gt; FunctionModuleMap;
         private FunctionPassManager FunctionPassManager;
+        private TargetMachine TargetMachine;
         private readonly PrototypeCollection FunctionPrototypes;
-
-        /// &lt;summary&gt;Delegate type to allow execution of a JIT&#39;d TopLevelExpression&lt;/summary&gt;
-        /// &lt;returns&gt;Result of evaluating the expression&lt;/returns&gt;
-        [UnmanagedFunctionPointer( System.Runtime.InteropServices.CallingConvention.Cdecl )]
-        private delegate double AnonExpressionFunc( );
         // &lt;/PrivateMembers&gt;
     }
 }
</code></pre><h2 id="driver-changes">Driver changes</h2>
<p>The bulk of the work needed to generate object files is in the &quot;driver&quot; application code. The changes
fall into two general categories:</p>
<ol>
<li>Command line argument handling</li>
<li>Generating the output files</li>
</ol>
<h3 id="adding-command-line-handling">Adding Command Line handling</h3>
<p>To allow providing a file like a traditional compiler the driver app needs to have some basic
command line argument handling. (&quot;Basic&quot; in this case means truly rudimentary ::Grin:: )
Generally this just gets a viable file path to use for the source code.</p>
<pre><code class="lang-csharp" name="ProcessArgs">// really simple command line handling, just loops through the args
private static (string SourceFilePath, bool WaitForDebugger, int ExitCode) ProcessArgs( string[ ] args )
{
    bool waitforDebugger = false;
    string sourceFilePath = string.Empty;
    foreach( string arg in args )
    {
        if( string.Compare( arg, &quot;waitfordebugger&quot;, StringComparison.InvariantCultureIgnoreCase ) == 0 )
        {
            waitforDebugger = true;
        }
        else
        {
            if( !string.IsNullOrWhiteSpace( sourceFilePath ) )
            {
                Console.Error.WriteLine( &quot;Source path already provided, unrecognized option: &#39;{0}&#39;&quot;, arg );
            }
            sourceFilePath = Path.GetFullPath( arg );
        }
    }

    WaitForDebugger( waitforDebugger );

    if( string.IsNullOrWhiteSpace( sourceFilePath ) )
    {
        Console.Error.WriteLine( &quot;Missing source file name!&quot; );
        return (null, false, -1);
    }

    if( !File.Exists( sourceFilePath ) )
    {
        Console.Error.WriteLine( &quot;Source file &#39;{0}&#39; - not found!&quot;, sourceFilePath );
        return (null, false, -2);
    }

    return (sourceFilePath, waitforDebugger, 0);
}
</code></pre><h3 id="update-main">Update Main()</h3>
<p>The real work comes in the Main application driver, though there isn&#39;t a lot of additional code
here either. The general plan is:</p>
<ol>
<li>Process the arguments to get the path to compile</li>
<li>Open the file for reading</li>
<li>Create a new target machine from the default triple of the host</li>
<li>Build the parser loop - specifying the file as the input source (instead of the default console)</li>
<li>Remove the REPL loop ready state console output handling as compilation isn&#39;t interactive</li>
<li>Once the parsing has completed, verify the module and emit the object file</li>
<li>For diagnostics use, also emit the LLVM IR textual form</li>
</ol>
<pre><code class="lang-csharp" name="Main">
/// &lt;summary&gt;C# version of the LLVM Kaleidoscope language tutorial&lt;/summary&gt;
/// &lt;param name=&quot;args&quot;&gt;Command line arguments to the application&lt;/param&gt;
/// &lt;returns&gt;0 on success; non-zero on error&lt;/returns&gt;
/// &lt;remarks&gt;
/// The command line options at present are &#39;WaitForDebugger&#39; and the source file name
///
/// Specifying &#39;WaitForDebugger&#39; will trigger a wait loop in Main() to wait
/// for an attached debugger if one is not yet attached. This is useful
/// for mixed mode native+managed debugging as the SDK project system does
/// not support that on launch.
/// &lt;/remarks&gt;
public static int Main( string[ ] args )
{
    (string sourceFilePath, bool waitForDebugger, int exitCode) = ProcessArgs( args );
    if( exitCode != 0 )
    {
        return exitCode;
    }

    string objFilePath = Path.ChangeExtension( sourceFilePath, &quot;.o&quot; );
    string irFilePath = Path.ChangeExtension( sourceFilePath, &quot;.ll&quot; );

    using( TextReader rdr = File.OpenText( sourceFilePath ) )
    using( InitializeLLVM( ) )
    {
        RegisterNative( );

        var machine = new TargetMachine( Triple.HostTriple );
        var parser = new ReplParserStack( LanguageLevel.MutableVariables );
        using( var generator = new CodeGenerator( parser.GlobalState, machine ) )
        {
            Console.WriteLine( &quot;Llvm.NET Kaleidoscope Compiler - {0}&quot;, parser.LanguageLevel );
            Console.WriteLine( &quot;Compiling {0}&quot;, sourceFilePath );

            var replLoop = new ReplLoop&lt;Value&gt;( generator, parser, DiagnosticRepresentations.None, rdr );
            replLoop.CodeGenerationError += OnGeneratorError;

            // time the parse and code generation
            var timer = System.Diagnostics.Stopwatch.StartNew( );
            replLoop.Run( );
            if( !generator.Module.Verify( out string errMsg ) )
            {
                Console.Error.WriteLine( errMsg );
            }
            else
            {
                machine.EmitToFile( generator.Module, objFilePath, CodeGenFileType.ObjectFile );
                timer.Stop( );

                Console.WriteLine( &quot;Wrote {0}&quot;, objFilePath );
                if( !generator.Module.WriteToTextFile( irFilePath, out string msg ) )
                {
                    Console.Error.WriteLine( msg );
                    return -1;
                }
                Console.WriteLine( &quot;CopmilationTiorTime: {0}&quot;, timer.Elapsed );
            }
        }
    }

    return 0;
}
</code></pre><h2 id="conclusion">Conclusion</h2>
<p>That&#39;s it - seriously! Very little change was needed, mostly deleting code. Looking at the changes
it should be clear that it is possible to support runtime choice between JIT and full native compilation
instead of deleting the JIT code. (Implementing this feature is &quot;left as an exercise for the reader&quot; ::Grin::)</p>
</article>
          </div>
          <div class="contribution-panel mobile-hide">
              <a href="https://github.com/UbiquityDotNET/Llvm.NET/blob/master/docfx/articles/Samples/Kaleidoscope-ch8.md/#L1" title="Improve this Doc" class="fab btn-warning pull-right"><i class="glyphicon glyphicon-pencil"></i></a>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            Copyright (C) 2017, Dot NET Foundation<br><strong>Build:</strong> 5.0.1-alpha--ci-BLD.436840127
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
