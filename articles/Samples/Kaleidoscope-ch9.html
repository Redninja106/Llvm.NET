<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>9. Kaleidoscope: Adding Debug Information | Llvm.NET </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="9. Kaleidoscope: Adding Debug Information | Llvm.NET ">
    <meta name="generator" content="docfx 2.42.2.0">
    
    <link rel="shortcut icon" href="../../favicon.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <meta property="docfx:navrel" content="../../toc">
    <meta property="docfx:tocrel" content="toc">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../DragonSharp48x48.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
                
                <ul class="nav level1 navbar-nav">
                      <li>
                          <a href="../../api/index.html" title="API Documentation">API Documentation</a>
                      </li>
                      <li>
                          <a href="../../articles/index.html" title="Articles">Articles</a>
                      </li>
                      <li>
                          <a href="https://github.com/UbiquityDotNET/Llvm.NET" title="GitHub Repository">GitHub Repository</a>
                      </li>
                      <li>
                          <a href="http://LLVM.org" title="LLVM.org">LLVM.org</a>
                      </li>
                      <li>
                          <a href="http://releases.llvm.org/6.0.1/docs/index.html" title="LLVM Docs">LLVM Docs</a>
                      </li>
                </ul>    </div>
          </div>
        </nav>
      </header>
      <div role="main" class="container body-content hide-when-search">
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div>
              <div class="sidefilter">
                <form class="toc-filter">
                  <span class="glyphicon glyphicon-filter filter-icon"></span>
                  <input type="text" id="toc_filter_input" placeholder="Enter here to filter..." onkeypress="if(event.keyCode==13) {return false;}">
                </form>
              </div>
              <div class="sidetoc">
                <div class="toc" id="toc">
                  
                  <ul class="nav level1">
                    <li class="">
                      <span class="expand-stub"></span>
                      <a class="">Code Generation</a>
                        
                        <ul class="nav level2">
                          <li class="">
                            <a href="codegeneration.html" title="CodeGenerator With Debug Information" class="">CodeGenerator With Debug Information</a>
                          </li>
                        </ul>  </li>
                    <li class="">
                      <span class="expand-stub"></span>
                      <a class="">Kaleidoscope</a>
                        
                        <ul class="nav level2">
                          <li class="">
                            <a href="Kaleidoscope.html" title="Chapter 1 - Language Introduction" class="">Chapter 1 - Language Introduction</a>
                          </li>
                          <li class="">
                            <a href="Kaleidoscope-ch2.html" title="Chapter 2 - Implementing the parser" class="">Chapter 2 - Implementing the parser</a>
                          </li>
                          <li class="">
                            <a href="Kaleidoscope-ch3.html" title="Chapter 3 - Generating LLVM IR" class="">Chapter 3 - Generating LLVM IR</a>
                          </li>
                          <li class="">
                            <a href="Kaleidoscope-ch4.html" title="Chapter 4 - JIT and Optimizer Support" class="">Chapter 4 - JIT and Optimizer Support</a>
                          </li>
                          <li class="">
                            <a href="Kaleidoscope-ch5.html" title="Chapter 5 - Control Flow" class="">Chapter 5 - Control Flow</a>
                          </li>
                          <li class="">
                            <a href="Kaleidoscope-ch6.html" title="Chapter 6 - User Defined Operators" class="">Chapter 6 - User Defined Operators</a>
                          </li>
                          <li class="">
                            <a href="Kaleidoscope-ch7.html" title="Chapter 7 - Mutable Variables" class="">Chapter 7 - Mutable Variables</a>
                          </li>
                          <li class="">
                            <a href="Kaleidoscope-ch7.1.html" title="Chapter 7.1 - Extreme Lazy JIT" class="">Chapter 7.1 - Extreme Lazy JIT</a>
                          </li>
                          <li class="">
                            <a href="Kaleidoscope-ch8.html" title="Chapter 8 - AOT Compilation" class="">Chapter 8 - AOT Compilation</a>
                          </li>
                          <li class="active">
                            <a href="Kaleidoscope-ch9.html" title="Chapter 9 - Debug Information" class="active">Chapter 9 - Debug Information</a>
                          </li>
                          <li class="">
                            <span class="expand-stub"></span>
                            <a class="">Additional Support</a>
                              
                              <ul class="nav level3">
                                <li class="">
                                  <a href="Kaleidoscope-Runtime.html" title="Kaleidoscope.Runtime" class="">Kaleidoscope.Runtime</a>
                                </li>
                                <li class="">
                                  <a href="Kaleidoscope-AST.html" title="Kaleidoscope AST" class="">Kaleidoscope AST</a>
                                </li>
                                <li class="">
                                  <a href="Kaleidoscope-ParseTreeVisitor.html" title="ParseTree Visitor" class="">ParseTree Visitor</a>
                                </li>
                                <li class="">
                                  <a href="Kaleidoscope-Parsetree-examples.html" title="ParseTree Examples" class="">ParseTree Examples</a>
                                </li>
                              </ul>  </li>
                        </ul>  </li>
                  </ul>        </div>
              </div>
            </div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="9-kaleidoscope-adding-debug-information">9. Kaleidoscope: Adding Debug Information</h1>

<p>So far in the progress of the Kaleidoscope tutorials we&#39;ve covered the basics of the language as a JIT
engine and even added ahead of time compilation into the mix so it is a full static compiled language. But
what happens if something goes wrong in one of the programs written in Kaleidoscope? How can a developer
debug applications written in this wonderful new language? Up until now, the answer is, you can&#39;t. This
chapter will add debugging information to the generated object file so that it is available for debuggers.</p>
<p>Source level debugging uses formatted data bound into the output binaries that helps the debugger map the
state of the application to the original source code that created it. The exact format of the data depends
on the target platform but the general idea holds for all of them. In order to isolate front-end developers
from the actual format LLVM uses an abstract form of debug data that is based on the common DWARF
debugging format. Internally, the LLVM target will transform the abstract representation into the actual
target binary form.</p>
<div class="NOTE"><h5>Note</h5><p>Debugging JIT code is rather complex as it requires awareness of the runtime within the debugger to
manage the execution and runtime state etc... Such functionality is beyond the scope of this tutorial.</p>
</div>
<h2 id="why-is-it-a-hard-problem">Why is it a hard problem?</h2>
<p>Debugging is a tough problem for a number of reasons, mostly revolving around optimized code. Optimizations
make keeping source level information more difficult. In LLVM the original source location information is
attached to each LLVM IR instruction. Optimization passes should keep the source location for any new
instructions created, but merged instructions only get to keep a single source location. This is generally
the cause of the observed &quot;jumping around&quot; when debugging optimized code. Additionally, optimizations can
move variables in ways that are either optimized out, shared in memory, in registers or otherwise difficult
to track. Thus, for the purposes of this tutorial we&#39;ll disable optimizations. (The DisableOptimizations
property of the CodeGenerator was added previously to aid in observing the effects of optimizations and
will serve to disable the optimizations for debugging in this chapter.)</p>
<h2 id="setup-for-emitting-debug-information">Setup for emitting debug information</h2>
<p>Debug information in Llvm.NET is created with the <a class="xref" href="../../api/Llvm.NET.DebugInfo.DebugInfoBuilder.html">DebugInfoBuilder</a>.
This is similar to the <a class="xref" href="../../api/Llvm.NET.Instructions.InstructionBuilder.html">InstructionBuilder</a>. Using the
DebugInfoBuilder requires a bit more knowledge on the general concepts of the DWARF debugging format, and
in particular the <a class="xref" href="http://releases.llvm.org/8.0.0/docs/SourceLevelDebugging.html">DebuggingMetadata</a> in LLVM. In Llvm.NET you don&#39;t need
to, and in fact can&#39;t, create an instance of the DebugInfoBuilder class. Instead it is lazy constructed
internally to a <a class="xref" href="../../api/Llvm.NET.BitcodeModule.html">BitcodeModule</a> and accessible through the
<a class="xref" href="../../api/Llvm.NET.BitcodeModule.DIBuilder.html#Llvm_NET_BitcodeModule_DIBuilder">DIBuilder</a> property. This simplifies creating the builder since it
is bound to the module.</p>
<p>Another important item for debug information is called the Compilation Unit. In Llvm.NET that is the
<a class="xref" href="../../api/Llvm.NET.DebugInfo.DICompileUnit.html">DICompileUnit</a>. The compile unit is the top level scope for
storing debug information, there is only ever one per module and generally it represents the full source
file that was used to create the module. Since the compile unit, like the builder is really tied to the
module it is exposed as the <a class="xref" href="../../api/Llvm.NET.BitcodeModule.DIBuilder.html#Llvm_NET_BitcodeModule_DIBuilder">DIBuilder</a> property. However, unlike
a builder it isn&#39;t something that a module can automatically construct without more information. Therefore,
Llvm.NET provides overloads for the creation of a module that includes the additional data needed to create
the DICompileUnit for you.</p>
<p>The updated InitializeModuleAndPassManager() function looks like this:</p>
<pre><code class="lang-csharp" name="InitializeModuleAndPassManager">private void InitializeModuleAndPassManager( string sourcePath )
{
    Module = Context.CreateBitcodeModule( Path.GetFileName( sourcePath ), SourceLanguage.C, sourcePath, &quot;Kaleidoscope Compiler&quot; );
    Module.TargetTriple = TargetMachine.Triple;
    Module.Layout = TargetMachine.TargetData;
    DoubleType = new DebugBasicType( Context.DoubleType, Module, &quot;double&quot;, DiTypeKind.Float );

    FunctionPassManager = new FunctionPassManager( Module )
                              .AddPromoteMemoryToRegisterPass( );

    if( !DisableOptimizations )
    {
        FunctionPassManager.AddInstructionCombiningPass( )
                           .AddReassociatePass( )
                           .AddGVNPass( )
                           .AddCFGSimplificationPass( );
    }

    FunctionPassManager.Initialize( );
}
</code></pre><p>There are a few points of interest here. First the compile unit is created for the Kaleidoscope language,
however it is using the <a class="xref" href="../../api/Llvm.NET.DebugInfo.SourceLanguage.html#Llvm_NET_DebugInfo_SourceLanguage_C">SourceLanguage.C</a> value. This is
because a debugger won&#39;t likely understand the Kaleidoscope language, runtime, or calling conventions.
(We just invented it and only now setting up debugger support after all!) The good news is that the
language follows the C language ABI in the code generation (generally a good idea unless you ave a really
good reason not to). Therefore, the C language is fairly accurate. This allows calling functions from the
debugger and it will execute them.</p>
<p>Another point to note is that the module ID is derived from the source file path and the source file path
is provided so that it becomes the root compile unit.</p>
<div class="IMPORTANT"><h5>Important</h5><p>It is important to note that when using the DIBuilder it must be &quot;finalized&quot; in order to resolve internal
forward references in the debug metadata. The exact details of this aren&#39;t generally relevant, just
remember that somewhere after generating all code and debug information to call the 
<a class="xref" href="../../api/Llvm.NET.DebugInfo.DebugInfoBuilder.Finish.html#Llvm_NET_DebugInfo_DebugInfoBuilder_Finish_Llvm_NET_DebugInfo_DISubProgram_">Finish</a>
method. (In Llvm.NET this method is called Finish() to avoid conflicts with the .NET runtime defined
Finalize() and to avoid confusion on the term as the idea of &quot;finalization&quot; has a very different meaning
in .NET then what happens here).</p>
</div>
<p>The tutorial takes care of finishing the debug information in Main after the running the parsing loop to
process all the input text for the source file.</p>
<pre><code class="lang-C#">replLoop.Run( );
generator.Module.DIBuilder.Finish( );
</code></pre><h2 id="functions">Functions</h2>
<p>With the basics of the DIBuilder and DICompile unit setup for the module it is time to focus on providing
debug information for functions. This requires adding a few extra calls to build the context of the debug
information for the function. The DWARF debug format that LLVM&#39;s debug metadata is based on calls these
&quot;SubPrograms&quot;. The new code builds a representation of the file the code is contained in as a new 
<a class="xref" href="../../api/Llvm.NET.DebugInfo.DIFile.html">DIFile</a>. In this case that is a bit redundant as all the code comes from
a single file and the compile unit already has the file info. However, that&#39;s not always true for all
languages (i.e. some sort of Include mechanism) so the file is created. It&#39;s not a problem as LLVM will
intern the file definition so that it won&#39;t actually end up with duplicates.</p>
<pre><code class="lang-csharp" name="GetIrDeclareFunction">
// Retrieves a Function for a prototype from the current module if it exists,
// otherwise declares the function and returns the newly declared function.
private IrFunction GetOrDeclareFunction( Prototype prototype )
{
    var function = Module.GetFunction( prototype.Name );
    if( function != null )
    {
        return function;
    }

    // extern declarations don&#39;t get debug information
    IrFunction retVal;
    if( prototype.IsExtern )
    {
        var llvmSignature = Context.GetFunctionType( Context.DoubleType, prototype.Parameters.Select( _ =&gt; Context.DoubleType ) );
        retVal = Module.AddFunction( prototype.Name, llvmSignature );
    }
    else
    {
        var parameters = prototype.Parameters;
        var debugFile = Module.DIBuilder.CreateFile( Module.DICompileUnit.File.FileName, Module.DICompileUnit.File.Directory );
        var signature = Context.CreateFunctionType( Module.DIBuilder, DoubleType, prototype.Parameters.Select( _ =&gt; DoubleType ) );
        var lastParamLocation = parameters.Count &gt; 0 ? parameters[ parameters.Count - 1 ].Location : prototype.Location;

        retVal = Module.CreateFunction( Module.DICompileUnit
                                      , prototype.Name
                                      , null
                                      , debugFile
                                      , ( uint )prototype.Location.StartLine
                                      , signature
                                      , false
                                      , true
                                      , ( uint )lastParamLocation.EndLine
                                      , prototype.IsCompilerGenerated ? DebugInfoFlags.Artificial : DebugInfoFlags.Prototyped
                                      , false
                                      );
    }

    int index = 0;
    foreach( var argId in prototype.Parameters )
    {
        retVal.Parameters[ index ].Name = argId.Name;
        ++index;
    }

    return retVal;
}
</code></pre><h2 id="debug-locations">Debug Locations</h2>
<p>The parse tree contains full location information for each parsed node in the tree. This allows building
debug location information for each node fairly easily. The general idea is to set the location in the
InstructionBuilder so that it is applied to all instructions emitted until it is changed. This saves on
manually adding the location on every instruction.</p>
<pre><code class="lang-csharp" name="EmitLocation">private void EmitLocation( IAstNode node )
{
    DIScope scope = Module.DICompileUnit;
    if( LexicalBlocks.Count &gt; 0 )
    {
        scope = LexicalBlocks.Peek( );
    }

    InstructionBuilder.SetDebugLocation( ( uint )node.Location.StartLine, ( uint )node.Location.StartColumn, scope );
}
</code></pre><h2 id="function-definition">Function Definition</h2>
<p>The next step is to update the function definition with attached debug information. The definition starts
by pushing a new lexical scope that is the functions declaration. This serves as the parent scope for all
the debug information generated for the function&#39;s implementation. The debug location info is cleared from
the builder to set up all the parameter variables with alloca, as before. Additionally, the debug
information for each parameter is constructed. After the function is fully generated the debug information
for the function is finalized, this is needed to allow for any optimizations to occur at the function
level.</p>
<pre><code class="lang-csharp" name="DefineFunction">public override Value Visit( FunctionDefinition definition )
{
    var function = GetOrDeclareFunction( definition.Signature );
    if( !function.IsDeclaration )
    {
        throw new CodeGeneratorException( $&quot;Function {function.Name} cannot be redefined in the same module&quot; );
    }

    LexicalBlocks.Push( function.DISubProgram );
    try
    {
        var entryBlock = function.AppendBasicBlock( &quot;entry&quot; );
        InstructionBuilder.PositionAtEnd( entryBlock );

        // Unset the location for the prologue emission (leading instructions with no
        // location in a function are considered part of the prologue and the debugger
        // will run past them when breaking on a function)
        EmitLocation( null );

        using( NamedValues.EnterScope( ) )
        {
            foreach( var param in definition.Signature.Parameters )
            {
                var argSlot = InstructionBuilder.Alloca( function.Context.DoubleType )
                                                .RegisterName( param.Name );
                AddDebugInfoForAlloca( argSlot, function, param );
                InstructionBuilder.Store( function.Parameters[ param.Index ], argSlot );
                NamedValues[ param.Name ] = argSlot;
            }

            foreach( LocalVariableDeclaration local in definition.LocalVariables )
            {
                var localSlot = InstructionBuilder.Alloca( function.Context.DoubleType )
                                                  .RegisterName( local.Name );
                AddDebugInfoForAlloca( localSlot, function, local );
                NamedValues[ local.Name ] = localSlot;
            }

            EmitBranchToNewBlock( &quot;body&quot; );

            var funcReturn = definition.Body.Accept( this );
            InstructionBuilder.Return( funcReturn );
            Module.DIBuilder.Finish( function.DISubProgram );
            function.Verify( );

            FunctionPassManager.Run( function );

            if( definition.IsAnonymous )
            {
                function.AddAttribute( FunctionAttributeIndex.Function, AttributeKind.AlwaysInline )
                        .Linkage( Linkage.Private );

                AnonymousFunctions.Add( function );
            }

            return function;
        }
    }
    catch( CodeGeneratorException )
    {
        function.EraseFromParent( );
        throw;
    }
}
</code></pre><h2 id="debug-info-for-parameters-and-local-variables">Debug info for Parameters and Local Variables</h2>
<p>Debug information for parameters and local variables is similar but not quite identical. Thus, two new
overloaded helper methods <code>AddDebugInfoForAlloca</code> handle attaching the correct debug information for
parameters and local variables.</p>
<pre><code class="lang-csharp" name="CreateEntryBlockAlloca">private void AddDebugInfoForAlloca( Alloca argSlot, IrFunction function, ParameterDeclaration param )
{
    uint line = ( uint )param.Location.StartLine;
    uint col = ( uint )param.Location.StartColumn;

    DILocalVariable debugVar = Module.DIBuilder.CreateArgument( function.DISubProgram
                                                              , param.Name
                                                              , function.DISubProgram.File
                                                              , line
                                                              , DoubleType
                                                              , true
                                                              , DebugInfoFlags.None
                                                              , checked(( ushort )( param.Index + 1 )) // Debug index starts at 1!
                                                              );
    Module.DIBuilder.InsertDeclare( argSlot
                                  , debugVar
                                  , new DILocation( Context, line, col, function.DISubProgram )
                                  , InstructionBuilder.InsertBlock
                                  );
}

private void AddDebugInfoForAlloca( Alloca argSlot, IrFunction function, LocalVariableDeclaration localVar )
{
    uint line = ( uint )localVar.Location.StartLine;
    uint col = ( uint )localVar.Location.StartColumn;

    DILocalVariable debugVar = Module.DIBuilder.CreateLocalVariable( function.DISubProgram
                                                                   , localVar.Name
                                                                   , function.DISubProgram.File
                                                                   , line
                                                                   , DoubleType
                                                                   , false
                                                                   , DebugInfoFlags.None
                                                                   );
    Module.DIBuilder.InsertDeclare( argSlot
                                  , debugVar
                                  , new DILocation( Context, line, col, function.DISubProgram )
                                  , InstructionBuilder.InsertBlock
                                  );
}
</code></pre><h2 id="conclusion">Conclusion</h2>
<p>Adding debugging information in LLVM IR is rather straight forward. The bulk of the problem is in tracking
the source location information in the parser. Fortunately for Llvm.NET version of Kaleidoscope, the ANTLR4
generated parsers do this for us already! Thus, combining the parser with Llvm.NET makes building a full
compiler for custom languages, including debug support a lot easier.</p>
</article>
          </div>
          <div class="contribution-panel mobile-hide">
              <a href="https://github.com/UbiquityDotNET/Llvm.NET/blob/master/docfx/articles/Samples/Kaleidoscope-ch9.md/#L1" title="Improve this Doc" class="fab btn-warning pull-right"><i class="glyphicon glyphicon-pencil"></i></a>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            Copyright (C) 2017, Dot NET Foundation<br><strong>Build:</strong> 8.0.0-alpha.0.0.ci-BLD.463895434
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
